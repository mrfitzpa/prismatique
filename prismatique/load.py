r"""For loading quantities from output files generated by ``prismatique``.

"""



#####################################
## Load libraries/packages/modules ##
#####################################

# For deserializing JSON objects.
import json



# For general array handling.
import numpy as np

# For validating and converting objects.
import czekitout.check
import czekitout.convert

# For loading objects from HDF5 files.
import h5pywrappers

# For checking whether floats are approximately zero.
import emconstants

# For creating ``hyperspy`` axes and signals.
import hyperspy.axes
import hyperspy.signals



# For calculating quantities related to the modelling of samples.
import prismatique.sample

# For convenient helper functions related to probe scan patterns.
import prismatique.scan

# For convenient helper functions related to STEM simulation output.
import prismatique.stem.output

# For constructing instances of the class :class:`prismatique.stem.sim.Params`
# and for some convenient helper functions.
import prismatique.stem.sim

# For constructing instances of the class :class:`prismatique.hrtem.sim.Params`
# and for some convenient helper functions.
import prismatique.hrtem.sim



############################
## Authorship information ##
############################

__author__     = "Matthew Fitzpatrick"
__copyright__  = "Copyright 2023"
__credits__    = ["Matthew Fitzpatrick"]
__maintainer__ = "Matthew Fitzpatrick"
__email__      = "mrfitzpa@uvic.ca"
__status__     = "Development"



##################################
## Define classes and functions ##
##################################

# List of public objects in objects.
__all__ = ["scan_pattern_type",
           "grid_dims_in_units_of_probe_shifts",
           "probe_positions",
           "output_layer_depths",
           "defocii",
           "num_slices",
           "num_frozen_phonon_configs_in_subset",
           "cbed_k_x_coords",
           "cbed_k_y_coords",
           "k_xy_coords_of_3d_stem_output",
           "integration_limits_of_2d_stem_output",
           "S_matrix_k_xy_vectors",
           "hrtem_beam_tilts",
           "hrtem_image_x_coords",
           "hrtem_image_y_coords"
           "potential_slices",
           "S_matrix_wavefunctions",
           "cbed_wavefunctions",
           "cbed_intensity_patterns",
           "com_momenta",
           "stem_intensity_images",
           "azimuthally_integrated_cbed_intensity_patterns",
           "hrtem_image_wavefunctions",
           "hrtem_intensity_image"]



###########################
## Define error messages ##
###########################



def scan_pattern_type(filename):
    r"""From a given STEM simulation output file, load the probe scan pattern 
    type stored or specified therein.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing or specifying the
        probe scan pattern type. Any non-temporary file generated by the
        function :func:`prismatique.stem.sim.run` that does not store potential
        slice or S-matrix data, is a valid file. In other words, any file
        generated by a STEM simulation with originally the basename
        ``"stem_sim_intensity_output.h5"``, ``"stem_sim_params.json"``, or a
        basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, where ``i``
        is a nonnegative integer.

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structure of ``prismatique`` STEM simulation output files.

    Returns
    -------
    pattern_type : "rectangular grid" | "jittered rectangular grid" | "no underlying rectangular grid"
        If ``scan_pattern_type=="rectangular_grid"``, then the probe positions
        making up the scan pattern lie exactly on a regular rectangular grid.
        If ``scan_pattern_type=="jittered rectangular grid"``, then the set of
        probe positions making up the scan pattern lie is equal to the set of
        positions obtained by generating an underlying rectangular grid to which
        a random positional deviation is applied to each point. In this case,
        the pattern is irregular but rectangular grid-like. If
        ``scan_pattern_type=="no underlying rectangular grid"``, then the scan
        pattern is irregular and not rectangular grid-like, i.e. this case
        is different from the previous two.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        sim_params = \
            prismatique.stem.sim.Params.load(filename)
        stem_system_model_params = \
            sim_params.core_attrs["stem_system_model_params"]
        scan_config = \
            stem_system_model_params.core_attrs["scan_config"]
        pattern_type = \
            prismatique.scan.pattern_type(scan_config)
    except:
        try:
            path_in_file = "/metadata/probe_positions"
            obj_id = h5pywrappers.obj.ID(filename, path_in_file)
            attr_name = "pattern type"
            attr_id = h5pywrappers.attr.ID(obj_id, attr_name)
            pattern_type = h5pywrappers.attr.load(attr_id)
            kwargs = {"obj": pattern_type, "obj_name": "pattern_type"}
            czekitout.check.if_str_like(**kwargs)
        except:
            func_name = "prismatique.load.scan_pattern_type"
            unformatted_err_msg = _scan_pattern_type_err_msg_1
            err_msg = unformatted_err_msg.format(filename, func_name)
            raise IOError(err_msg)

    return pattern_type



def grid_dims_in_units_of_probe_shifts(filename):
    r"""From a given STEM simulation output file, load the underlying grid 
    dimensions of the probe scan pattern, in units of probe shifts, stored or 
    specified therein.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing or specifying
        underlying grid dimensions of the probe scan pattern. Any non-temporary
        file generated by the function :func:`prismatique.stem.sim.run` that
        does not store potential slice or S-matrix data, is a valid file. In
        other words, any file generated by a STEM simulation with originally the
        basename ``"stem_sim_intensity_output.h5"``, ``"stem_sim_params.json"``,
        or a basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, where ``i``
        is a nonnegative integer. 

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structure of ``prismatique`` STEM simulation output files.

    Returns
    -------
    grid_dims : "N/A" | `array_like` (`float`, shape=(``2``))
        If ``prismatique.load.scan_pattern_type(filename) == "no underlying
        rectangular grid"``, then ``grid_dimensions_in_units_of_probe_shifts ==
        "N/A"``, indicating that there is no notion of grid dimensions that is
        applicable to the scan pattern used. Otherwise, if
        ``prismatique.load.scan_pattern_type(filename) != "no underlying
        rectangular grid"``, then ``grid_dims[0]`` and ``grid_dims[1]`` are the
        number of probe positions along the :math:`x`- and :math:`y`-dimensions
        respectively of the underlying rectangular grid of the scanning pattern.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        sim_params = \
            prismatique.stem.sim.Params.load(filename)
        stem_system_model_params = \
            sim_params.core_attrs["stem_system_model_params"]
        sample_specification = \
            stem_system_model_params.core_attrs["sample_specification"]
        scan_config = \
            stem_system_model_params.core_attrs["scan_config"]
        kwargs = \
            {"sample_specification": sample_specification,
             "scan_config": scan_config}
        grid_dims = \
            prismatique.scan.grid_dims_in_units_of_probe_shifts(**kwargs)
    except:
        try:
            path_in_file = "/metadata/probe_positions"
            obj_id = h5pywrappers.obj.ID(filename, path_in_file)
            attr_name = "grid dims in units of probe shifts"
            attr_id = h5pywrappers.attr.ID(obj_id, attr_name)
            grid_dims = h5pywrappers.attr.load(attr_id)
            kwargs = {"obj": grid_dims, "obj_name": "grid_dims"}
            czekitout.check.if_pair_of_positive_ints(**kwargs)
        except:
            func_name = "prismatique.load.grid_dims_in_units_of_probe_shifts"
            unformatted_err_msg = _grid_dims_in_units_of_probe_shifts_err_msg_1
            err_msg = unformatted_err_msg.format(filename, func_name)
            raise IOError(err_msg)

    return grid_dims



def probe_positions(filename, force_2_col_shape=True):
    r"""From a given STEM simulation output file, load the probe positions 
    stored or specified therein.

    Note that the cartesian coordinate system used to define the probe positions
    has its origin coinciding with the bottom left corner of the sample's
    supercell [see the documentation for the class
    :class:`prismatique.discretization.Params` for a discussion on sample
    supercells].

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the probe positions
        or specifying the scan pattern. Any non-temporary file generated by the
        function :func:`prismatique.stem.sim.run` that does not store potential
        slice or S-matrix data, is a valid file. In other words, any file
        generated by a STEM simulation with originally the basename
        ``"stem_sim_intensity_output.h5"``, ``"stem_sim_params.json"``, or a
        basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, where ``i``
        is a nonnegative integer.

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` STEM simulation output files.
    force_2_col_shape : `bool`, optional
        If ``force_2_col_shape`` is set to ``False`` and
        ``prismatique.load.scan_pattern_type(filename) == "rectangular_grid"``,
        then the return object storing the probe positions, ``probe_positions``,
        is not a two-column array. Otherwise, ``probe_positions`` is a
        two-column array. See the description below of ``probe_positions`` for
        more details.

    Returns
    -------
    probe_positions : `array_like` (`float`, shape=(``num_probe_positions``, ``2``)) | `array_like` (`float`, shape=(``Y_dim``, ``X_dim``, ``2``))
        Let ``num_probe_positions`` be the number of probe positions. If
        ``force_2_col_shape==True`` or
        ``prismatique.load.scan_pattern_type(filename) != "rectangular_grid"``,
        then ``probe_positions[i][0]`` and ``probe_positions[i][1]`` are the
        :math:`x`- and :math:`y`-components of the :math:`i^{\text{th}}` probe
        position in units of Å, where ``i`` is an integer satisfying
        ``0<=i<num_probe_positions``.

        If ``prismatique.load.scan_pattern_type(filename) ==
        "rectangular_grid"``, then the probe positions lie exactly on a
        rectangular grid with ``X_dim`` positions along the :math:`x`-axis,
        ``Y_dim`` positions along the :math:`y`-axis. Let ``rx`` be the set of
        possible :math:`x`-coordinates of the probe in ascending order, and
        ``ry`` be the set of possible :math:`y`-coordinates of the probe in
        descending order, both in units of Å. In the case that
        ``force_2_col_shape==False`` and
        ``prismatique.load.scan_pattern_type(filename) == "rectangular_grid"``,
        ``probe_positions[ry_idx][rx_idx][0]=rx[rx_idx]`` and
        ``probe_positions[ry_idx][rx_idx][1]=ry[ry_idx]``, where ``rx_idx`` and
        ``ry_idx`` are non-negative integers satisfying ``rx_idx<X_dim`` and
        ``ry_idx<Y_dim`` respectively.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)

    kwargs = {"obj": force_2_col_shape, "obj_name": "force_2_col_shape"}
    force_2_col_shape = czekitout.convert.to_bool(**kwargs)
    
    try:
        sim_params = \
            prismatique.stem.sim.Params.load(filename)
        stem_system_model_params = \
            sim_params.core_attrs["stem_system_model_params"]
        sample_specification = \
            stem_system_model_params.core_attrs["sample_specification"]
        scan_config = \
            stem_system_model_params.core_attrs["scan_config"]
        kwargs = \
            {"sample_specification": sample_specification,
             "scan_config": scan_config,
             "filename": None}
        probe_positions = \
            prismatique.scan.generate_probe_positions(**kwargs)
    except:
        try:
            path_in_file = "/metadata/probe_positions"
            dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
            dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
            probe_positions = dataset[()]
            dataset.file.close()
            kwargs = {"obj": probe_positions, "obj_name": "probe_positions"}
            czekitout.check.if_real_two_column_numpy_matrix(**kwargs)
        except:
            func_name = "prismatique.load.probe_positions"
            unformatted_err_msg = _probe_positions_err_msg_1
            err_msg = unformatted_err_msg.format(filename, func_name)
            raise IOError(err_msg)

    if not force_2_col_shape:
        if scan_pattern_type(filename) == "rectangular grid":
            X_dim, Y_dim = grid_dims_in_units_of_probe_shifts(filename)
            probe_positions = np.reshape(probe_positions,
                                         newshape=(X_dim, Y_dim, 2))
            probe_positions = np.transpose(probe_positions, axes=[1, 0, 2])
            probe_positions = probe_positions[::-1, :, :]

    return probe_positions



def output_layer_depths(filename):
    r"""From a given STEM simulation output file, load the output layer depths 
    stored or specified therein.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the output layer
        depths. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run` that does not store potential slice or
        S-matrix data, is a valid file. In other words, any file generated by a
        STEM simulation with originally the basename
        ``"stem_sim_intensity_output.h5"``, ``"stem_sim_params.json"``, or a
        basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, where ``i``
        is a nonnegative integer. 

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structure of ``prismatique`` STEM simulation output files.

    Returns
    -------
    output_layer_depths : `array_like` (`float`, ndim=1)
        The output layer depths, in units of Å, in ascending order. Note that
        for STEM simulations that use the PRISM algorithm,
        ``output_layer_depths`` is a single-element array, where the single
        element is the the :math:`z`-dimension of the sample's supercell in
        units of Å [see the documentation for the class
        :class:`prismatique.discretization.Params` for a discussion on the
        sample's supercell].

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        sim_params = \
            prismatique.stem.sim.Params.load(filename)
        stem_system_model_params = \
            sim_params.core_attrs["stem_system_model_params"]
        sample_specification = \
            stem_system_model_params.core_attrs["sample_specification"]
        output_params = \
            sim_params.core_attrs["output_params"]
        alg_specific_params = \
            output_params.core_attrs["alg_specific_params"]
        kwargs = \
            {"sample_specification": sample_specification,
             "alg_specific_params": alg_specific_params}
        layer_depths = \
            prismatique.stem.output.layer_depths(**kwargs)
    except:
        try:
            path_in_file = "/metadata/output_layer_depths"
            dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
            dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
            layer_depths = dataset[()]
            dataset.file.close()
            kwargs = {"obj": layer_depths, "obj_name": "layer_depths"}
            czekitout.check.if_real_numpy_array_1d(**kwargs)
        except:
            func_name = "prismatique.load.output_layer_depths"
            unformatted_err_msg = _output_layer_depths_err_msg_1
            err_msg = unformatted_err_msg.format(filename, func_name)
            raise IOError(err_msg)

    return layer_depths



def defocii(filename):
    r"""From a given ``prismatique`` output file, load the beam defocii stored 
    or specified therein that were used in the simulation.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the beam
        defocii. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run` or :func:`prismatique.hrtem.sim.run`,
        with originally the basename ``"stem_sim_params.json"``,
        ``"hrtem_sim_params.json"``, a basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, or
        ``"hrtem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, where ``i``
        is a nonnegative integer.

        See the documentation for the classes
        :class:`prismatique.stem.output.Params` and
        :class:`prismatique.hrtem.output.Params` for discussions on the layout
        and structure of ``prismatique`` STEM and HRTEM simulation output files
        respectively.

    Returns
    -------
    beam_defocii : `array_like` (`float`, ndim=1)
        The beam defocii, in units of Å, in ascending order.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        sim_params = prismatique.stem.sim.Params.load(filename)
        beam_defocii = prismatique.stem.sim._defocii(sim_params)
    except:
        try:
            sim_params = prismatique.hrtem.sim.Params.load(filename)
            beam_defocii = prismatique.hrtem.sim._defocii(sim_params)
        except:
            try:
                path_in_file = "/metadata/defocii"
                dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
                dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
                beam_defocii = dataset[()]
                dataset.file.close()
                kwargs = {"obj": beam_defocii, "obj_name": "beam_defocii"}
                czekitout.check.if_real_numpy_array_1d(**kwargs)
            except:
                func_name = "prismatique.load.defocii"
                unformatted_err_msg = _defocii_err_msg_1
                err_msg = unformatted_err_msg.format(filename, func_name)
                raise IOError(err_msg)

    return beam_defocii



def num_slices(filename):
    r"""From a given ``prismatique`` output file, load the number of slices used
    to partition the sample, stored or specified therein.

    See the documentation for the class
    :class:`prismatique.discretization.Params` for a discussion on this slicing
    scheme.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing or specifying the
        number of slices used to partition the sample. Any non-temporary file
        generated by the function
        :func:`prismatique.sample.generate_potential_slices`,
        :func:`prismatique.stem.sim.run`, or :func:`prismatique.hrtem.sim.run`
        with originally the basename ``"sample_model_params.json"``, or a
        basename of the form ``"potential_slices_of_subset_"+str(i)+".h5"`` is
        valid, where ``i`` is nonnegative integer.

    Returns
    -------
    num_sample_supercell_slices : `int`
        The number of slices :math:`N_{\text{slices}}` used to partition the
        sample.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        with open(filename, "r") as file_obj:
            serializable_rep = json.load(file_obj)

        de_pre_serialize_sample_specification = \
            prismatique.stem.system._de_pre_serialize_sample_specification
        sample_specification = \
            de_pre_serialize_sample_specification(serializable_rep)
        num_sample_supercell_slices = \
            prismatique.sample.num_slices(sample_specification)
    except:
        try:
            kwargs = \
                {"filenames": (filename,)}
            sample_specification = \
                prismatique.sample.PotentialSliceSubsetIDs(**kwargs)
            num_sample_supercell_slices = \
                prismatique.sample.num_slices(sample_specification)
        except:
            func_name = "prismatique.load.num_slices"
            unformatted_err_msg = _num_slices_err_msg_1
            err_msg = unformatted_err_msg.format(filename, func_name)
            raise IOError(err_msg)

    return num_sample_supercell_slices



def num_frozen_phonon_configs_in_subset(filename):
    r"""From a given ``prismatique`` output file that stores data related to a 
    frozen phonon configuration subset, load the number of frozen phonon 
    configurations making up the subset.

    See the documentation for the class :class:`prismatique.thermal.Params` for
    a discussion on frozen phonon configurations and subsets thereof.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing ``prismatique``
        output related to the frozen phonon configuration subset of interest.
        Any non-temporary file generated by the function
        :func:`prismatique.sample.generate_potential_slices`,
        :func:`prismatique.sample.generate_S_matrices`,
        :func:`prismatique.stem.sim.run`, or :func:`prismatique.hrtem.sim.run`
        with originally a basename of the form
        ``"potential_slices_of_subset_"+str(i)+".h5"``,
        ``"S_matrices_of_subset_"+str(i)+".h5"``, 
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, or
        ``"hrtem_sim_wavefunction_output_of_subset_"+str(i)+".h5"`` is valid,
        where ``i`` is a nonnegative integer.

        See the documentation for the classes
        :class:`prismatique.stem.output.Params` and
        :class:`prismatique.hrtem.output.Params` for discussions on the layout
        and structure of ``prismatique`` STEM and HRTEM simulation output files
        respectively.

    Returns
    -------
    num_configs_in_subset : `int`
        The number of frozen phonon configurations in the subset specified by
        the output file.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        path_in_file = "/data"
        group_id = h5pywrappers.obj.ID(filename, path_in_file)
        group = h5pywrappers.group.load(group_id, read_only=False)

        key_1 = "4D_STEM/complex_valued_DPs"
        key_2 = "image_wavefunctions"
        if key_1 in group:
            num_configs_in_subset = group[key_1].shape[1]
        elif key_2 in group:
            num_configs_in_subset = group[key_2].shape[0]
        else:
            err_msg = \
                _num_frozen_phonon_configs_in_subset_err_msg_1.format(filename)
            raise IOError(err_msg)
    except:
        kwargs = {"filenames": (filename,)}
        func_alias = prismatique.sample.num_frozen_phonon_configs_in_subset
        try:
            sample_specification = \
                prismatique.sample.PotentialSliceSubsetIDs(**kwargs)
            num_configs_in_subset = \
                func_alias(sample_specification, subset_idx=0)
        except:
            try:
                sample_specification = \
                    prismatique.sample.SMatrixSubsetIDs(**kwargs)
                num_configs_in_subset = \
                    func_alias(sample_specification, subset_idx=0)
            except:
                func_name = \
                    "prismatique.load.num_frozen_phonon_configs_in_subset"
                unformatted_err_msg = \
                    _num_frozen_phonon_configs_in_subset_err_msg_2
                err_msg = \
                    unformatted_err_msg.format(filename, func_name)
                raise IOError(err_msg)

    return num_configs_in_subset



def cbed_k_x_coords(filename):
    r"""From a given STEM simulation output file that stores CBED patterns, load
    the :math:`k_x`-coordinates of said CBED patterns.

    See also the documentation for the class :class:`prismatique.cbed.Params`
    for a discussion on CBED patterns.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the CBED patterns
        of interest. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run` with originally the basename
        ``"stem_sim_intensity_output.h5"``, or a basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"`` is valid,
        where ``i`` is a nonnegative integer. Note that CBED patterns stored in
        the former are postprocessed, whereas those stored in the latter are
        not, hence the :math:`k_x`-coordinates of the former set of CBED
        patterns are generally different than the latter set.

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` STEM simulation output files. See
        also the documentation for the class :class:`prismatique.cbed.Params`
        for a discussion on postprocessing CBED patterns.

    Returns
    -------
    k_x : `array_like` (`float`, ndim=1)
        The set of :math:`k_x`-coordinates, in ascending order, and in units of 
        1/Å.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        path_in_file = "/metadata/k_x"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        k_x = dataset[()]
        dataset.file.close()
        kwargs = {"obj": k_x, "obj_name": "k_x"}
        czekitout.check.if_real_numpy_array_1d(**kwargs)
    except:
        func_name = "prismatique.load.cbed_k_x_coords"
        unformatted_err_msg = _cbed_k_x_coords_err_msg_1
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return k_x



def cbed_k_y_coords(filename):
    r"""From a given STEM simulation output file that stores CBED patterns, load
    the :math:`k_y`-coordinates of said CBED patterns.

    See also the documentation for the class :class:`prismatique.cbed.Params`
    for a discussion on CBED patterns.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the CBED patterns
        of interest. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run` with originally the basename
        ``"stem_sim_intensity_output.h5"``, or a basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"`` is valid,
        where ``i`` is a nonnegative integer. Note that CBED patterns stored in
        the former are postprocessed, whereas those stored in the latter are
        not, hence the :math:`k_x`-coordinates of the former set of CBED
        patterns are generally different than the latter set.

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` STEM simulation output files. See
        also the documentation for the class :class:`prismatique.cbed.Params`
        for a discussion on postprocessing CBED patterns.

    Returns
    -------
    k_y : `array_like` (`float`, ndim=1)
        The set of :math:`k_y`-coordinates, in descending order, and in units of
        1/Å.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        path_in_file = "/metadata/k_y"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        k_y = dataset[()]
        dataset.file.close()
        kwargs = {"obj": k_y, "obj_name": "k_y"}
        czekitout.check.if_real_numpy_array_1d(**kwargs)
    except:
        func_name = "prismatique.load.cbed_k_y_coords"
        unformatted_err_msg = _cbed_k_y_coords_err_msg_1
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return k_y



def k_xy_coords_of_3d_stem_output(filename):
    r"""From a given STEM simulation output file that stores 3D-STEM integrated
    CBED intensity patterns, load the radial scattering momenta coordinates 
    :math:`k_{xy}` of said integrated CBED intensity patterns.

    See the documentation for the class :class:`prismatique.stem.output.Params`
    for a discussion on 3D-STEM integrated CBED intensity patterns.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the integrated CBED
        intensity patterns of interest. Any non-temporary file generated by the
        function :func:`prismatique.stem.sim.run` with originally the basename
        ``"stem_sim_intensity_output.h5"`` is valid. 

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` STEM simulation output files. 

    Returns
    -------
    k_xy : `array_like` (`float`, ndim=1)
        The set of :math:`k_xy`-coordinates, in ascending order, and in units of
        1/Å.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        path_in_file = "/metadata/k_xy"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        k_xy = dataset[()]
        dataset.file.close()
        kwargs = {"obj": k_xy, "obj_name": "k_xy"}
        czekitout.check.if_real_numpy_array_1d(**kwargs)
    except:
        func_name = "prismatique.load.k_xy_coords_of_3d_stem_output"
        unformatted_err_msg = _k_xy_coords_of_3d_stem_output_err_msg_1
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return k_xy



def integration_limits_of_2d_stem_output(filename):
    r"""From a given STEM simulation output file that stores 2D-STEM integrated
    CBED intensity patterns, load the 2D-STEM integration limits.

    See the documentation for the class :class:`prismatique.stem.output.Params`
    for a discussion on 2D-STEM integrated CBED intensity patterns, i.e. STEM
    intensity images.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the integrated CBED
        intensity patterns of interest. Any non-temporary file generated by the
        function :func:`prismatique.stem.sim.run` with originally the basename
        ``"stem_sim_intensity_output.h5"`` is valid. 

        See the documentation for the class
        :class:`prismatique.stem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` STEM simulation output files. 

    Returns
    -------
    integration_limits : `array_like` (`float`, shape=(``2``,))
        ``integration_limits[0]`` is the lower integration limit in mrads;
        ``integration_limits[1]`` is the upper integration limit in mrads.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        integration_limits = []
        attr_names = ("lower integration limit in mrads",
                      "upper integration limit in mrads")
        path_in_file = "/data/2D_STEM/integrated_intensities"
        obj_id = h5pywrappers.obj.ID(filename, path_in_file)
        for attr_name in attr_names:
            attr_id = h5pywrappers.attr.ID(obj_id, attr_name)
            integration_limits.append(h5pywrappers.attr.load(attr_id))
        integration_limits = tuple(integration_limits)
        kwargs = {"obj": integration_limits, "obj_name": "integration_limits"}
        czekitout.check.if_nonnegative_float_seq(**kwargs)
        if integration_limits[1] < integration_limits[0]:
            raise ValueError(_integration_limits_of_2d_stem_output_err_msg_1)
    except:
        func_name = "prismatique.load.integration_limits_of_2d_stem_output"
        unformatted_err_msg = _integration_limits_of_2d_stem_output_err_msg_2
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return integration_limits



def S_matrix_k_xy_vectors(filename):
    r"""From a given output file generated by a STEM simulation using the PRISM
    algorithm, load the :math:`\mathbf{k}_{xy}`-momentum vectors of the plane
    waves used to calculate the :math:`S`-matrices of said STEM simulation.

    See the documentation for the subpackage :mod:`prismatique.stem` for a
    discussion on :math:`S`-matrices, :math:`S_{m_{x},m_{y}}\left(x,y\right)`,
    and the PRISM algorithm. As discussed therein, each pair :math:`\left(m_x,
    m_y\right)` corresponds to a different :math:`\mathbf{k}_{xy}`-momentum
    vector. In ``prismatic``, each pair :math:`\left(m_x, m_y\right)` is
    essentially mapped to a unique integer :math:`i`.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file specifying the
        :math:`\mathbf{k}_{xy}`-momentum vectors. Any non-temporary file
        generated by the function :func:`prismatique.stem.sim.run` using the
        PRISM algorithm, with originally the basename ``"stem_sim_params.json"``
        is valid.

    Returns
    -------
    k_xy_vectors : `array_like` (`float`, shape=(``num_vectors``, ``2``))
        If we let ``num_vectors`` be the number of
        :math:`\mathbf{k}_{xy}`-momentum vectors, then ``k_xy_vectors[i][0]``
        and ``k_xy_vectors[i][1]`` are the :math:`x`- and :math:`y`-components
        of the ``i`` th :math:`\mathbf{k}_{xy}`-momentum vector in units of 1/Å,
        where ``0<=i<num_vectors``.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        sim_params = \
            prismatique.stem.sim.Params.load(filename)
        stem_system_model_params = \
            sim_params.core_attrs["stem_system_model_params"]
        sample_specification = \
            stem_system_model_params.core_attrs["sample_specification"]
        probe_model_params = \
            stem_system_model_params.core_attrs["probe_model_params"]

        output_params = \
            sim_params.core_attrs["output_params"]
        alg_specific_output_params = \
            output_params.core_attrs["alg_specific_params"]

        if "z_start_output" in alg_specific_output_params.core_attrs:
            err_msg = _S_matrix_k_xy_vectors_err_msg_1.format(filename)
            raise IOError(err_msg)

        num_sample_supercell_slices = \
            prismatique.sample.num_slices(sample_specification)
        
        kwargs = {"sample_specification": sample_specification,
                  "probe_model_params": probe_model_params}
        k_xy_vectors = prismatique.sample.S_matrix_k_xy_vectors(**kwargs)
        
    except:
        func_name = "prismatique.load.S_matrix_k_xy_vectors"
        unformatted_err_msg = _S_matrix_k_xy_vectors_err_msg_2
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return k_xy_vectors



def hrtem_beam_tilts(filename):
    r"""From a given HRTEM simulation output file, load the beam tilts stored 
    or specified therein that were used in the simulation.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the beam tilts. Any
        non-temporary file generated by the function
        :func:`prismatique.hrtem.sim.run`, with originally the basename
        ``"hrtem_sim_params.json"``, or a basename of the form
        ``"hrtem_sim_wavefunction_output_of_subset_"+str(i)+".h5"``, where ``i``
        is a nonnegative integer.

        See the documentation for the class
        :class:`prismatique.hrtem.output.Params` for a discussion on the layout
        and structure of ``prismatique`` HRTEM simulation output files
        respectively.

    Returns
    -------
    beam_tilts : `array_like` (`float`, shape=(``num_tilts``, ``2``))
        If we let ``num_tilts`` be the number of beam tilts, then
        ``beam_tilts[i][0]`` and ``beam_tilts[i][1]`` are the :math:`x`- and
        :math:`y`-components of the ``i`` th beam tilt in units of mrads, where
        ``0<=i<num_vectors``.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        sim_params = prismatique.hrtem.sim.Params.load(filename)
        beam_tilts = prismatique.hrtem.sim._tilt_series(sim_params)
    except:
        try:
            path_in_file = "/metadata/tilts"
            dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
            dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
            beam_tilts = dataset[()]
            dataset.file.close()
            kwargs = {"obj": beam_tilts, "obj_name": "beam_tilts"}
            czekitout.check.if_real_two_column_numpy_matrix(**kwargs)
        except:
            func_name = "prismatique.load.hrtem_beam_tilts"
            unformatted_err_msg = _hrtem_beam_tilts_err_msg_1
            err_msg = unformatted_err_msg.format(filename, func_name)
            raise IOError(err_msg)

    return beam_tilts



def hrtem_image_x_coords(filename):
    r"""From a given HRTEM simulation output file that stores HRTEM images, load
    the :math:`x`-coordinates of said HRTEM images.

    See also the documentation for the class
    :class:`prismatique.hrtem.image.Params` for a discussion on HRTEM images.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the HRTEM images of
        interest. Any non-temporary file generated by the function
        :func:`prismatique.hrtem.sim.run` with originally the basename
        ``"hrtem_sim_intensity_output.h5"``, or a basename of the form
        ``"hrtem_sim_wavefunction_output_of_subset_"+str(i)+".h5"`` is valid,
        where ``i`` is a nonnegative integer. Note that HRTEM images stored in
        the former are postprocessed, whereas those stored in the latter are
        not, hence the :math:`x`-coordinates of the former set of HRTEM images
        are generally different than the latter set.

        See the documentation for the class
        :class:`prismatique.hrtem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` HRTEM simulation output files. See
        also the documentation for the class
        :class:`prismatique.hrtem.image.Params` for a discussion on
        postprocessing HRTEM images.

    Returns
    -------
    r_x : `array_like` (`float`, ndim=1)
        The set of :math:`x`-coordinates, in ascending order, and in units of Å.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        path_in_file = "/metadata/r_x"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        r_x = dataset[()]
        dataset.file.close()
        kwargs = {"obj": r_x, "obj_name": "r_x"}
        czekitout.check.if_real_numpy_array_1d(**kwargs)
    except:
        func_name = "prismatique.load.hrtem_image_x_coords"
        unformatted_err_msg = _hrtem_image_x_coords_err_msg_1
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return r_x



def hrtem_image_y_coords(filename):
    r"""From a given HRTEM simulation output file that stores HRTEM images, load
    the :math:`y`-coordinates of said HRTEM images.

    See also the documentation for the class
    :class:`prismatique.hrtem.image.Params` for a discussion on HRTEM images.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the HRTEM images of
        interest. Any non-temporary file generated by the function
        :func:`prismatique.hrtem.sim.run` with originally the basename
        ``"hrtem_sim_intensity_output.h5"``, or a basename of the form
        ``"hrtem_sim_wavefunction_output_of_subset_"+str(i)+".h5"`` is valid,
        where ``i`` is a nonnegative integer. Note that HRTEM images stored in
        the former are postprocessed, whereas those stored in the latter are
        not, hence the :math:`y`-coordinates of the former set of HRTEM images
        are generally different than the latter set.

        See the documentation for the class
        :class:`prismatique.hrtem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` HRTEM simulation output files. See
        also the documentation for the class
        :class:`prismatique.hrtem.image.Params` for a discussion on
        postprocessing HRTEM images.

    Returns
    -------
    r_y : `array_like` (`float`, ndim=1)
        The set of :math:`y`-coordinates, in ascending order, and in units of Å.

    """
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)
    try:
        path_in_file = "/metadata/r_y"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        r_y = dataset[()]
        dataset.file.close()
        kwargs = {"obj": r_y, "obj_name": "r_y"}
        czekitout.check.if_real_numpy_array_1d(**kwargs)
    except:
        func_name = "prismatique.load.hrtem_image_y_coords"
        unformatted_err_msg = _hrtem_image_y_coords_err_msg_1
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return r_y



def potential_slices(filename,
                     multi_dim_slice=None,
                     num_superslices=0,
                     average_thermally=False,
                     average_laterally_in_space=False):
    r"""From a given ``prismatique`` output file that stores potential slices of
    a sample, load a specified subcollection of said potential slices into a
    ``hyperspy`` signal.

    See also the documentation for the class
    :class:`prismatique.discretization.Params` for a discussion on potential
    slices.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the potential
        slices of interest. Any non-temporary file generated by the function
        :func:`prismatique.sample.generate_potential_slices`,
        :func:`prismatique.stem.sim.run`, or :func:`prismatique.hrtem.sim.run`,
        with originally a basename of the form
        ``"potential_slices_of_subset_"+str(i)+".h5"`` is valid, where ``i`` is
        a nonnegative integer.
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional
        The "multidimensional slice object", which specifies the subcollection
        of potential slices to load from file. We define a multi-dimensional
        slice object as a `tuple` of items which contains at most one item being
        a `list` of integers, and the remaining items being `slice` and/or `int`
        objects.

        If ``multi_dim_slice`` is a `tuple` of length 2, then
        ``multi_dim_slice[0]`` specifies a set of atomic configuration indices,
        where each atomic configuration index corresponds to a frozen phonon
        configuration; and ``multi_dim_slice[1]`` specifies a set of sample
        slice indices, where each sample slice index corresponds to a different
        sample slice at a different :math:`z`-coordinate. In this case, the
        current Python function will load the potential slices of the frozen
        phonon configurations specified by ``multi_dim_slice[0]``, at the
        :math:`z`-coordinates specified by ``multi_dim_slice[1]``. Note that a
        sample slice index :math:`n` corresponds to a sample slice at the
        :math:`z`-coordinate :math:`z_{n}`, where :math:`z_{n}` is given by
        Eq. :eq:`z_n_in_potential_params`.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the
        potential slices stored in the file are loaded.
    num_superslices : `int`, optional
        The number of potential superslices to form from the potential slices to
        be loaded from file, per frozen phonon configuration. We define a
        potential superslice as the sum of a group of potential slices. Let
        ``N`` be the total number of potential slices stored in the file per
        frozen phonon configuration, ``M`` be the number of slices to be loaded
        per frozen phonon configuration, ``n=int(np.ceil(M /
        max(num_superslices, 1)))``, and ``single_dim_slice=multi_dim_slice[1]
        if multi_dim_slice is not None else slice(None)``. If
        ``num_superslices`` is a positive `int`, then for each integer ``i``
        satisfying ``0<=i<num_superslices-1``, the ``i`` th superslice is
        calculated by summing the potential slices with the corresponding
        indices ``np.arange(N)[single_dim_slice][i*n:(i+1)*n]``, and for
        ``i==num_superslices-1``, the ``i`` th superslice is calculated by
        summing the potential slices with the corresponding indices
        ``np.arange(N)[single_dim_slice][i*n:M]``. Otherwise, if
        ``num_superslices==0``, then no potential superslices are formed.
    average_thermally : `bool`, optional
        If ``average_thermally`` is set to ``True``, then the potential slices
        and superslices are averaged over the selected frozen phonon
        configurations. Otherwise, the potential slices are not averaged over
        the selected frozen phonon configurations.
    average_laterally_in_space : `bool`, optional
        If ``average_laterally_in_space`` is set to ``True``, then the potential
        slices and superslices are averaged laterally in space. Otherwise, the
        potential slices are not averaged laterally in space.

    Returns
    -------
    potential_slice_signal : :class:`hyperspy.signal.BaseSignal` | :class:`hyperspy._signals.signal2d.Signal2D`
        The subcollection of potential slices, stored in an instance of the
        :class:`hyperspy._signals.signal2d.Signal2D` class if
        ``average_laterally_in_space`` is set to ``False``, otherwise it is
        stored in an instance of the :class:`hyperspy.signal.BaseSignal`. See
        the documentation and/or reference guide for the :hyperspy:`hyperspy <>`
        package for details on how to use instances of the
        :class:`hyperspy._signals.signal2d.Signal2D` and
        :class:`hyperspy.signal.BaseSignal` classes.
    navigational_to_original_indices_map : `dict`
        A dictionary that maps the navigational indices of the hyperspy signal
        ``potential_slice_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original atomic configuration
        indices map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["atomic_config_indices"][i]``
        yields the atomic configuration index specified in the expression
        ``single_dim_slice=multi_dim_slice[0] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of ``potential_slice_signal``, where
        ``i`` is a nonnegative integer smaller than the total number of atomic
        configuration indices specified in ``single_dim_slice``.

    """
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("atomic_config_indices", "slice_indices"),
              "average_thermally": average_thermally,
              "average_laterally_in_space": average_laterally_in_space,
              "num_superslices": num_superslices,
              "func_to_calc_sizes_of_navigational_space_axes": \
              _sizes_of_navigational_space_axes_for_potential_slices,
              "func_to_initialize_sample_specification_signal": \
              _initialize_potential_slice_signal}

    potential_slice_signal, navigational_to_original_indices_map = \
        _sample_specification_signal_and_indices_map(**kwargs)

    return potential_slice_signal, navigational_to_original_indices_map


def _sizes_of_navigational_space_axes_for_potential_slices(filename):
    try:
        kwargs = \
            {"filenames": (filename,)}
        sample_specification = \
            prismatique.sample.PotentialSliceSubsetIDs(**kwargs)
        
        kwargs = \
            {"sample_specification": sample_specification, "subset_idx": 0}
        num_frozen_phonon_configs_in_subset = \
            prismatique.sample._num_frozen_phonon_configs_in_subset(**kwargs)
    except:
        func_name = \
            "prismatique.load.potential_slices"
        unformatted_err_msg = \
            _sizes_of_navigational_space_axes_for_potential_slices_err_msg_1
        err_msg = \
            unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    num_sample_supercell_slices = \
        prismatique.sample.num_slices(sample_specification)

    sizes_of_navigational_space_axes = (num_frozen_phonon_configs_in_subset,
                                        num_sample_supercell_slices)

    return sizes_of_navigational_space_axes



def _initialize_potential_slice_signal(filename,
                                       multi_dim_slice,
                                       indices_map,
                                       indices_map_keys,
                                       extra_kwargs):
    average_thermally = extra_kwargs["average_thermally"]
    average_laterally_in_space = extra_kwargs["average_laterally_in_space"]
    num_superslices = extra_kwargs["num_superslices"]
    
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "signal_dtype": "float32",
              "use_two_axes_to_map_probe_position_if_possible": False,
              "extra_kwargs": extra_kwargs}

    kwargs = {"filenames": (filename,)}
    mod_alias = prismatique.sample
    sample_specification = mod_alias.PotentialSliceSubsetIDs(**kwargs)

    N_x, N_y = \
        mod_alias._supercell_xy_dims_in_pixels(sample_specification)
    Delta_x, Delta_y = \
        mod_alias._supercell_lateral_pixel_size(sample_specification)
    average_laterally = \
        average_laterally_in_space  # Alias for brevity.

    signal_title = ((average_thermally*"Thermally ")
                    + ((average_thermally and average_laterally)*"and ")
                    + (average_laterally*"Spatially ")
                    + ((average_thermally or average_laterally)*"Averaged ")
                    + "Potential "
                    + ((num_superslices>0)*"Superslice")
                    + ((num_superslices==0)*"Slice"))

    signal_space_offsets = [-((N_x-1) * Delta_x) / 2,
                            ((N_y-1) * Delta_y) / 2]*(not average_laterally)

    kwargs = \
        {"filename": filename,
         "multi_dim_slice": multi_dim_slice,
         "indices_map": indices_map,
         "indices_map_keys": indices_map_keys,
         "signal_space_sizes": [N_x, N_y]*(not average_laterally),
         "signal_space_scales": [Delta_x, -Delta_y]*(not average_laterally),
         "signal_space_offsets": signal_space_offsets,
         "signal_space_units": ["Å", "Å"]*(not average_laterally),
         "signal_dtype": "float32",
         "signal_title": signal_title,
         "use_two_axes_to_map_probe_position_if_possible": False,
         "extra_kwargs": extra_kwargs}

    potential_slice_signal = _initialize_signal_for_generic_case(**kwargs)

    return potential_slice_signal



def _initialize_signal_for_generic_case(
        filename,
        multi_dim_slice,
        indices_map,
        indices_map_keys,
        signal_space_sizes,
        signal_space_scales,
        signal_space_offsets,
        signal_space_units,
        signal_dtype,
        signal_title,
        use_two_axes_to_map_probe_position_if_possible,
        extra_kwargs):
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "extra_kwargs": extra_kwargs}
    navigational_space_dims = _navigational_space_dims(**kwargs)
    navigational_space_rank = len(navigational_space_dims)
    
    signal_data_shape = navigational_space_dims + list(signal_space_sizes)[::-1]
    if len(signal_data_shape) == 0:
        signal_data_shape = [1]

    signal_data = np.zeros(signal_data_shape, dtype=signal_dtype)

    signal_metadata = _signal_metadata(filename,
                                       multi_dim_slice,
                                       indices_map,
                                       indices_map_keys,
                                       signal_title,
                                       extra_kwargs)
    
    signal_axes = _signal_axes(filename,
                               multi_dim_slice,
                               indices_map,
                               indices_map_keys,
                               signal_space_sizes,
                               signal_space_scales,
                               signal_space_offsets,
                               signal_space_units,
                               signal_title,
                               use_two_axes_to_map_probe_position_if_possible,
                               extra_kwargs)

    signal = _build_signal(signal_data,
                           signal_metadata,
                           signal_axes,
                           navigational_space_rank)

    return signal
    


def _navigational_space_dims(filename,
                             multi_dim_slice,
                             indices_map,
                             indices_map_keys,
                             use_two_axes_to_map_probe_position_if_possible,
                             extra_kwargs):
    navigational_space_dims = []
    zip_obj = zip(indices_map_keys, multi_dim_slice)
    for indices_map_key, single_dim_slice in zip_obj:
        M = len(indices_map[indices_map_key])

        if indices_map_key == "probe_indices":
            scan_pattern_type = prismatique.load.scan_pattern_type(filename)
            if ((scan_pattern_type == "rectangular_grid")
                and (single_dim_slice == slice(None))
                and (use_two_axes_to_map_probe_position_if_possible)):
                grid_dims = grid_dims_in_units_of_probe_shifts(filename)
                navigational_space_dims.append(grid_dims[1])
                navigational_space_dims.append(grid_dims[0])
            elif not isinstance(single_dim_slice, int):
                navigational_space_dims.append(M)
        elif indices_map_key == "slice_indices":
            if extra_kwargs.get("num_superslices", 0) > 0:
                navigational_space_dims.append(extra_kwargs["num_superslices"])
            elif not isinstance(single_dim_slice, int):
                navigational_space_dims.append(M)
        elif indices_map_key == "atomic_config_indices":
            if ((not extra_kwargs.get("average_thermally", False))
                and (not isinstance(single_dim_slice, int))):
                navigational_space_dims.append(M)
        elif not isinstance(single_dim_slice, int):
            navigational_space_dims.append(M)

    return navigational_space_dims



def _signal_metadata(filename,
                     multi_dim_slice,
                     indices_map,
                     indices_map_keys,
                     signal_title,
                     extra_kwargs):
    prismatique_metadata = _prismatique_metadata(filename,
                                                 multi_dim_slice,
                                                 indices_map,
                                                 indices_map_keys,
                                                 extra_kwargs)

    if signal_title == "Center of Mass Momentum":
        pixel_value_units = "1/Å"
    elif "Potential" in signal_title:
        pixel_value_units = "Å*V"
    else:
        pixel_value_units = "dimensionless"

    signal_metadata = {"General": {"title": signal_title},
                       "Signal": {"pixel value units": pixel_value_units}, 
                       "Prismatique": prismatique_metadata}

    return signal_metadata



def _prismatique_metadata(filename,
                          multi_dim_slice,
                          indices_map,
                          indices_map_keys,
                          extra_kwargs):
    candidate_prismatique_metadata_keys = \
        _candidate_prismatique_metadata_keys(indices_map_keys)

    zip_obj = zip(indices_map_keys,
                  multi_dim_slice,
                  candidate_prismatique_metadata_keys)
    
    func_alias = \
        _prismatique_metadata_resulting_from_single_dim_slices_of_length_one

    prismatique_metadata = func_alias(filename, zip_obj)

    if "atomic_config_indices" in indices_map_keys:
        if extra_kwargs.get("average_thermally", False):
            num_configs_in_subset = \
                num_frozen_phonon_configs_in_subset(filename)
            prismatique_metadata["original atomic configuration indices"] = \
                tuple(np.arange(num_configs_in_subset)[multi_dim_slice[0]])

    if "slice_indices" in indices_map_keys:
        prismatique_metadata["slice thickness"] = _slice_thickness(filename)
        num_superslices = extra_kwargs.get("num_superslices", 0)
        if num_superslices > 0:
            kwargs = \
                {"filename": filename,
                 "indices_map": indices_map,
                 "num_superslices": num_superslices}
            prismatique_metadata["original slice indices of superslices"] = \
                _original_slice_indices_of_superslices(**kwargs)            
        
    if "k_xy_indices" in indices_map_keys:
        prismatique_metadata["integration limits"] = \
            integration_limits_of_2d_stem_output(filename)

    return prismatique_metadata



def _candidate_prismatique_metadata_keys(indices_map_keys):
    candidate_prismatique_metadata_keys = []
    for indices_map_key in indices_map_keys:
        if indices_map_key == "output_layer_indices":
            prismatique_metadata_key = "original output layer index"
        elif indices_map_key == "atomic_config_indices":
            prismatique_metadata_key = "original atomic configuration index"
        elif indices_map_key == "defocus_indices":
            prismatique_metadata_key = "original defocus index"
        elif indices_map_key == "probe_indices":
            prismatique_metadata_key = "original probe index"
        elif indices_map_key == "vector_component_indices":
            prismatique_metadata_key = "original vector component index"
        elif indices_map_key == "tilt_indices":
            prismatique_metadata_key = "original tilt index"
        elif indices_map_key == "k_xy_indices":
            prismatique_metadata_key = r"original $k_{xy}$ index"
        elif indices_map_key == "k_xy_vector_indices":
            prismatique_metadata_key = r"original $\mathbf{k}_{xy}$ index"
        elif indices_map_key == "slice_indices":
            prismatique_metadata_key = "original slice index"
        else:
            continue

        candidate_prismatique_metadata_keys.append(prismatique_metadata_key)

    return candidate_prismatique_metadata_keys



def _prismatique_metadata_resulting_from_single_dim_slices_of_length_one(
        filename, zip_obj):
    prismatique_metadata = dict()
    
    for triplet in zip_obj:
        indices_map_key = triplet[0]
        single_dim_slice = triplet[1]
        candidate_prismatique_metadata_key = triplet[2]
        
        if isinstance(single_dim_slice, int):
            original_idx = \
                single_dim_slice
            prismatique_metadata[candidate_prismatique_metadata_key] = \
                original_idx

            if indices_map_key == "output_layer_indices":
                extra_key = "output layer depth"
                extra_val = output_layer_depths(filename)[single_dim_slice]
            elif indices_map_key == "defocus_indices":
                extra_key = "defocus"
                extra_val = defocii(filename)[single_dim_slice]
            elif indices_map_key == "probe_indices":
                extra_key = "probe position"
                extra_val = probe_positions(filename)[single_dim_slice].tolist()
            elif indices_map_key == "slices_indices":
                extra_key = r"$z$-coordinate"
                extra_val = single_dim_slice * _slice_thickness(filename)
            elif indices_map_key == "tilt_indices":
                extra_key = "beam tilt"
                extra_val = hrtem_beam_tilts(filename)[single_dim_slice]
                extra_val = extra_val.tolist()
            elif indices_map_key == "vector_component_indices":
                extra_key = "vector component"
                extra_val = (r"$x$", r"$y$")[single_dim_slice]
            elif indices_map_key == "k_xy_indices":
                extra_key = r"$k_{xy}$"
                k_xy_coords = k_xy_coords_of_3d_stem_output(filename)
                extra_val = k_xy_coords[single_dim_slice]
            else:
                continue

            prismatique_metadata[extra_key] = extra_val

    return prismatique_metadata



def _slice_thickness(filename):
    kwargs = \
        {"filenames": (filename,)}
    sample_specification = \
        prismatique.sample.PotentialSliceSubsetIDs(**kwargs)
    slice_thickness = \
        prismatique.sample._supercell_slice_thickness(sample_specification)

    return slice_thickness



def _original_slice_indices_of_superslices(filename,
                                           indices_map,
                                           num_superslices):
    original_slice_indices_of_superslices = []
    slice_idx_subcollection = indices_map["slice_indices"].tolist()
    
    if num_superslices == 0:
        original_slice_indices_of_superslices.append(slice_idx_subcollection)
    else:
        N = _sizes_of_navigational_space_axes_for_potential_slices(filename)
        M = len(slice_idx_subcollection)
        n = int(np.ceil(M / num_superslices))
        for idx in range(num_superslices):
            beg = idx*n
            end = (idx+1)*n if (idx < num_superslices-1) else M
            indices_of_superslice = tuple(slice_idx_subcollection[beg:end])
            original_slice_indices_of_superslices.append(indices_of_superslice)

    original_slice_indices_of_superslices = \
        tuple(original_slice_indices_of_superslices)

    return original_slice_indices_of_superslices



def _signal_axes(filename,
                 multi_dim_slice,
                 indices_map,
                 indices_map_keys,
                 signal_space_sizes,
                 signal_space_scales,
                 signal_space_offsets,
                 signal_space_units,
                 signal_title,
                 use_two_axes_to_map_probe_position_if_possible,
                 extra_kwargs):
    kwargs = {"filename": filename,
              "signal_space_units": signal_space_units,
              "signal_title": signal_title,
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible}
    axes_labels = _signal_space_axes_labels(**kwargs)
    sizes = list(signal_space_sizes)
    scales = list(signal_space_scales)
    offsets = list(signal_space_offsets)
    units = list(signal_space_units)

    del kwargs["signal_space_units"]
    del kwargs["signal_title"]
    kwargs["indices_map"] = indices_map
    kwargs["indices_map_keys"] = indices_map_keys
    kwargs["multi_dim_slice"] = multi_dim_slice
    kwargs["axes_labels"] = axes_labels
    kwargs["sizes"] = sizes
    kwargs["scales"] = scales
    kwargs["offsets"] = offsets
    kwargs["units"] = units
    kwargs["extra_kwargs"] = extra_kwargs

    axes_labels, sizes, scales, offsets, units = \
        _add_navigational_space_axes_properties_to_current_sets(**kwargs)

    if len(signal_space_units) == 2:
        if abs(scales[-2]+scales[-1]) < emconstants.tol:
            scales[-1] = -scales[-2]

    signal_axes = []
    for axis_idx in range(len(units)):
        axis = hyperspy.axes.UniformDataAxis(size=sizes[axis_idx],
                                             scale=scales[axis_idx],
                                             offset=offsets[axis_idx],
                                             units=units[axis_idx])
        axis.name = axes_labels[axis_idx]
        signal_axes.append(axis)

    return signal_axes



def _signal_space_axes_labels(
        filename,
        signal_space_units,
        signal_title,
        use_two_axes_to_map_probe_position_if_possible):
    if signal_title in ("STEM Intensity Image", "Center of Mass Momentum"):
        scan_pattern_type = prismatique.load.scan_pattern_type(filename)
        if ((scan_pattern_type == "rectangular_grid")
            and (use_two_axes_to_map_probe_position_if_possible)):
            axes_labels = [r"probe $x$-coordinate", r"probe $y$-coordinate"]
            return signal_space_axes_labels

    if len(signal_space_units) == 0:
        signal_space_axes_labels = []
    else:
        if signal_space_units[0] == "dimensionless":
            signal_space_axes_labels = ["original probe index"]
        elif signal_space_units[0] == "Å":
            signal_space_axes_labels = [r"$x$", r"$y$"]
        else:
            if len(signal_space_units) == 1:
                signal_space_axes_labels = [r"$k_{xy}$"]
            else:
                signal_space_axes_labels = [r"$k_x$", r"$k_y$"]

    return signal_space_axes_labels



def _add_navigational_space_axes_properties_to_current_sets(
        filename,
        indices_map,
        indices_map_keys,
        multi_dim_slice,
        axes_labels,
        sizes,
        scales,
        offsets,
        units,
        use_two_axes_to_map_probe_position_if_possible,
        extra_kwargs):
    kwargs = \
        {"indices_map_keys": indices_map_keys,
         "extra_kwargs": extra_kwargs}
    candidate_navigational_space_axes_labels = \
        _candidate_navigational_space_axes_labels(**kwargs)

    zip_obj = zip(indices_map_keys,
                  multi_dim_slice,
                  candidate_navigational_space_axes_labels)
    for triplet in zip_obj:
        indices_map_key, single_dim_slice, candidate_axis_label = triplet

        if ((indices_map_key == "slice_indices")
             and ((extra_kwargs.get("num_superslices", 0) == 1)
                  or ((extra_kwargs.get("num_superslices", 0) == 0)
                      and isinstance(single_dim_slice, int)))):
            continue
        elif (isinstance(single_dim_slice, int)
              or ((indices_map_key == "atomic_config_indices")
                  and extra_kwargs.get("average_thermally", False))):
            continue
            
        if indices_map_key == "probe_indices":
            scan_pattern_type = prismatique.load.scan_pattern_type(filename)
            if ((scan_pattern_type == "rectangular_grid")
                and (single_dim_slice == slice(None))
                and (use_two_axes_to_map_probe_position_if_possible)):
                probe_positions = probe_positions(filename,
                                                  force_2_col_shape=False)
                Y_dim, X_dim, _ = probe_positions.shape
                dr_x = probe_positions[0, 1, 0] - probe_positions[0, 0, 0]
                dr_y = probe_positions[0, 0, 1] - probe_positions[1, 0, 1]
                axes_labels = [r"probe $y$-coordinate"] + axes_labels
                axes_labels = [r"probe $x$-coordinate"] + axes_labels
                sizes = [X_dim, Y_dim] + sizes
                scales = [dr_x, -dr_y] + scales
                offsets = [probe_positions[0, 0, 1]] + offsets
                offsets = [probe_positions[0, 0, 0]] + offsets
                units = ["Å", "Å"] + units
                continue
            
        axes_labels = [candidate_axis_label] + axes_labels
        if ((indices_map_key == "slice_indices")
            and (extra_kwargs.get("num_superslices", 0) > 0)):
            sizes = [extra_kwargs["num_superslices"]] + sizes
        else:
            sizes = [len(indices_map[indices_map_key])] + sizes
        scales = [1] + scales
        offsets = [0] + offsets
        units = ["dimensionless"] + units

    return axes_labels, sizes, scales, offsets, units



def _candidate_navigational_space_axes_labels(indices_map_keys, extra_kwargs):
    candidate_prismatique_metadata_keys = \
        _candidate_prismatique_metadata_keys(indices_map_keys)
    
    candidate_navigational_space_axes_labels = []
    for key in candidate_prismatique_metadata_keys:
        axis_label = key.replace("original", "navigational")
        if (("slice" in axis_label)
            and (extra_kwargs.get("num_superslices", 0) > 0)):
            axis_label = axis_label.replace("slice", "superslice")
        candidate_navigational_space_axes_labels.append(axis_label)
    
    return candidate_navigational_space_axes_labels



def _build_signal(signal_data,
                  signal_metadata,
                  signal_axes,
                  navigational_space_rank):
    signal_space_rank = len(signal_data.shape) - navigational_space_rank
    
    current_signal_title = signal_metadata["General"]["title"]

    if signal_data.dtype in ("complex64", "complex128"):
        signal = hyperspy.signals.ComplexSignal2D(data=signal_data,
                                                  metadata=signal_metadata)
    else:
        if signal_space_rank == 2:
            signal = hyperspy.signals.Signal2D(data=signal_data,
                                               metadata=signal_metadata)
        elif signal_space_rank == 1:
            signal = hyperspy.signals.Signal1D(data=signal_data,
                                               metadata=signal_metadata)
        else:
            signal = hyperspy.signals.BaseSignal(data=signal_data,
                                                 metadata=signal_metadata)

    for idx, axis in enumerate(signal_axes):
        signal.axes_manager[idx].update_from(axis)
        signal.axes_manager[idx].name = axis.name

    return signal



def _sample_specification_signal_and_indices_map(
        filename,
        multi_dim_slice,
        indices_map_keys,
        average_thermally,
        average_laterally_in_space,
        num_superslices,
        func_to_calc_sizes_of_navigational_space_axes,
        func_to_initialize_sample_specification_signal):
    kwargs = {"obj": average_thermally, "obj_name": "average_thermally"}
    average_thermally = czekitout.convert.to_bool(**kwargs)

    kwargs = {"obj": average_laterally_in_space,
              "obj_name": "average_laterally_in_space"}
    average_laterally_in_space = czekitout.convert.to_bool(**kwargs)

    kwargs = {"obj": num_superslices, "obj_name": "num_superslices"}
    num_superslices = czekitout.convert.to_nonnegative_int(**kwargs)

    extra_kwargs = {"average_thermally": average_thermally,
                    "average_laterally_in_space": average_laterally_in_space,
                    "num_superslices": num_superslices}

    kwargs = \
        {"filename": filename,
         "multi_dim_slice": multi_dim_slice,
         "indices_map_keys": indices_map_keys,
         "func_to_calc_sizes_of_navigational_space_axes": \
         func_to_calc_sizes_of_navigational_space_axes}
    indices_map, multi_dim_slice = \
        _indices_map_and_converted_multi_dim_slice(**kwargs)

    del kwargs["func_to_calc_sizes_of_navigational_space_axes"]
    kwargs["multi_dim_slice"] = multi_dim_slice
    kwargs["indices_map"] = indices_map
    kwargs["extra_kwargs"] = extra_kwargs
    
    sample_specification_signal = \
        func_to_initialize_sample_specification_signal(**kwargs)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "sample_specification_signal": sample_specification_signal,
              "extra_kwargs": extra_kwargs}        
    _load_data_into_sample_specification_signal(**kwargs)

    kwargs = {"indices_map": indices_map,
              "filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "use_two_axes_to_map_probe_position_if_possible": False,
              "extra_kwargs": extra_kwargs}
    _clean_indices_map(**kwargs)

    return sample_specification_signal, indices_map



def _indices_map_and_converted_multi_dim_slice(
        filename,
        multi_dim_slice,
        indices_map_keys,
        func_to_calc_sizes_of_navigational_space_axes):
    kwargs = {"obj": filename, "obj_name": "filename"}
    filename = czekitout.convert.to_str_from_path_like(**kwargs)

    expected_length = len(indices_map_keys)
    multi_dim_slice = _check_and_convert_multi_dim_slice(multi_dim_slice,
                                                         expected_length)

    sizes_of_navigational_axes = \
        func_to_calc_sizes_of_navigational_space_axes(filename)

    indices_map = dict()
    
    zip_obj = zip(indices_map_keys, sizes_of_navigational_axes, multi_dim_slice)
    for dim, triplet in enumerate(zip_obj):
        key, axis_size, single_dim_slice = triplet
        
        if isinstance(single_dim_slice, int):
            single_dim_slice = [single_dim_slice]
            
        all_indices_along_dim = np.arange(axis_size)
        
        try:
            selected_indices_along_dim = all_indices_along_dim[single_dim_slice]
        except:
            unformatted_err_msg = _indices_map_err_msg_1
            err_msg = unformatted_err_msg.format(dim, axis_size)
            raise IndexError(err_msg)

        temp_idx_set = set(selected_indices_along_dim)
        if len(selected_indices_along_dim) != len(temp_idx_set):
            unformatted_err_msg = _indices_map_err_msg_2
            err_msg = unformatted_err_msg.format(dim)
            raise ValueError(err_msg)
        
        indices_map[key] = selected_indices_along_dim

    return indices_map, multi_dim_slice



def _check_and_convert_multi_dim_slice(multi_dim_slice, expected_length):
    if multi_dim_slice is None:
        multi_dim_slice = tuple([slice(None)]*expected_length)
    else:
        kwargs = {"obj": multi_dim_slice, "obj_name": "multi_dim_slice"}
        multi_dim_slice = czekitout.convert.to_multi_dim_slice(**kwargs)
    _check_multi_dim_slice_length(multi_dim_slice, expected_length)

    return multi_dim_slice



def _check_multi_dim_slice_length(multi_dim_slice, expected_length):
    if len(multi_dim_slice) != expected_length:
        unformatted_err_msg = _check_multi_dim_slice_length_err_msg_1
        err_msg = unformatted_err_msg.format(expected_length)
        raise ValueError(err_msg)

    return None



def _load_data_into_sample_specification_signal(filename,
                                                multi_dim_slice,
                                                indices_map,
                                                sample_specification_signal,
                                                extra_kwargs):
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "sample_specification_signal": sample_specification_signal}
    
    if "Potential" in sample_specification_signal.metadata.General.title:
        kwargs["extra_kwargs"] = extra_kwargs
        _load_data_into_potential_slice_signal(**kwargs)
    else:
        _load_data_into_S_matrix_wavefunction_signal(**kwargs)

    return None



def _load_data_into_potential_slice_signal(filename,
                                           multi_dim_slice,
                                           indices_map,
                                           sample_specification_signal,
                                           extra_kwargs):
    average_thermally = extra_kwargs["average_thermally"]
    average_laterally_in_space = extra_kwargs["average_laterally_in_space"]
    num_superslices = extra_kwargs["num_superslices"]
    
    original_index_set_1 = indices_map["atomic_config_indices"]
    slice_idx_subsets = _original_slice_indices_of_superslices(filename,
                                                               indices_map,
                                                               num_superslices)

    for nav_idx_1, original_idx_1 in enumerate(original_index_set_1):
        path_in_file = ("4DSTEM_simulation/data/realslices/ppotential_fp"
                        + str(original_idx_1).rjust(4, "0") + "/data")
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        for superslice_idx, slice_idx_subset in enumerate(slice_idx_subsets):
            hdf5_multi_dim_slice = (slice(None), slice(None), slice_idx_subset)
            kwargs = {"dataset_id": dataset_id,
                      "multi_dim_slice": hdf5_multi_dim_slice}
            datasubset_id = h5pywrappers.datasubset.ID(**kwargs)
            temp_datasubset = h5pywrappers.datasubset.load(datasubset_id)

            temp_multi_dim_slice_1 = []
            if (not average_thermally) and (len(original_index_set_1) > 1):
               temp_multi_dim_slice_1.append(nav_idx_1)
            if num_superslices == 0:
                if len(slice_idx_subset) > 1:
                    temp_multi_dim_slice_1.append(slice(None))
            elif num_superslices > 1:
                temp_multi_dim_slice_1.append(superslice_idx)
            if not average_laterally_in_space:
                temp_multi_dim_slice_1 += [slice(None), slice(None)]
            temp_multi_dim_slice_1 = (tuple(temp_multi_dim_slice_1)
                                      if (len(temp_multi_dim_slice_1) > 0)
                                      else (slice(None),))

            if ((len(temp_datasubset.shape) == 3)
                and ((num_superslices > 0)
                     or ((num_superslices == 0)
                         and (temp_datasubset.shape[-1] == 1)))):
                temp_datasubset = np.sum(temp_datasubset, axis=(2,))
            if average_laterally_in_space:
                if len(temp_datasubset.shape) == 3:
                    temp_datasubset = np.mean(temp_datasubset, axis=(0, 1))
                else:
                    temp_datasubset = np.mean(temp_datasubset, axis=(0, 1))
                    temp_datasubset = np.array([temp_datasubset])
                
            axes = list(range(len(temp_datasubset.shape)))[::-1]

            temp_multi_dim_slice_2 = \
                [slice(None), slice(None, None, -1), slice(None)]
            temp_multi_dim_slice_2 = \
                tuple(temp_multi_dim_slice_2[3-len(temp_datasubset.shape):])

            sample_specification_signal.data[temp_multi_dim_slice_1] += \
                np.transpose(temp_datasubset, axes=axes)[temp_multi_dim_slice_2]

    if average_thermally:
        sample_specification_signal.data /= len(original_index_set_1)
                
    return None



def _load_data_into_S_matrix_wavefunction_signal(filename,
                                                 multi_dim_slice,
                                                 indices_map,
                                                 sample_specification_signal):
    original_index_set_1 = indices_map["atomic_config_indices"]
    original_index_set_2 = (indices_map["k_xy_vector_indices"]
                            if (len(indices_map["k_xy_vector_indices"]) > 1)
                            else indices_map["k_xy_vector_indices"][0])

    for nav_idx_1, original_idx_1 in enumerate(original_index_set_1):
        path_in_file = ("4DSTEM_simulation/data/realslices/smatrix_fp"
                        + str(nav_idx_1).rjust(4, "0") + "/data")

        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        hdf5_multi_dim_slice = (slice(None), slice(None), original_index_set_2)
        kwargs = {"dataset_id": dataset_id,
                  "multi_dim_slice": hdf5_multi_dim_slice}
        datasubset_id = h5pywrappers.datasubset.ID(**kwargs)
        datasubset = h5pywrappers.datasubset.load(datasubset_id)

        temp_multi_dim_slice_1 = [slice(None), slice(None)]
        if len(datasubset.shape) == 3:
            temp_multi_dim_slice_1 = [slice(None)] + temp_multi_dim_slice_1
        if len(original_index_set_1) > 1:
            temp_multi_dim_slice_1 = [nav_idx_1] + temp_multi_dim_slice_1
        temp_multi_dim_slice_1 = tuple(temp_multi_dim_slice_1)

        axes = list(range(len(datasubset.shape)))[::-1]

        temp_multi_dim_slice_2 = \
            [slice(None), slice(None, None, -1), slice(None)]
        temp_multi_dim_slice_2 = \
            tuple(temp_multi_dim_slice_2[3-len(datasubset.shape):])

        sample_specification_signal.data[temp_multi_dim_slice_1] += \
            np.transpose(datasubset, axes=axes)[temp_multi_dim_slice_2]

    return None



def _clean_indices_map(indices_map,
                       filename,
                       multi_dim_slice,
                       use_two_axes_to_map_probe_position_if_possible,
                       extra_kwargs):
    indices_map_keys = tuple(indices_map.keys())
    for dim, key in enumerate(indices_map_keys):
        if ((key == "slice_indices")
            and ((extra_kwargs.get("num_superslices", 0) > 0)
                 or ((extra_kwargs.get("num_superslices", 0) == 0)
                     and isinstance(multi_dim_slice[dim], int)))):
            del indices_map[key]
        elif (isinstance(multi_dim_slice[dim], int)
              or ((key == "atomic_config_indices")
                  and extra_kwargs.get("average_thermally", False))):
            del indices_map[key]
        elif key == "probe_indices":
            scan_pattern_type = prismatique.load.scan_pattern_type(filename)
            if ((scan_pattern_type == "rectangular_grid")
                and (multi_dim_slice[-1] == slice(None))
                and (use_two_axes_to_map_probe_position_if_possible)):
                del indices_map[key]

    return None



def S_matrix_wavefunctions(filename, multi_dim_slice=None):
    r"""From a given ``prismatique`` output file that stores :math:`S`-matrices,
    load a specified subcollection of said :math:`S`-matrices into a 
    ``hyperspy`` signal.

    See the documentation for the subpackage :mod:`prismatique.stem` for a
    discussion on :math:`S`-matrices.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the
        :math:`S`-matrices of interest. Any non-temporary file generated by the
        function :func:`prismatique.sample.generate_S_matrices`, or
        :func:`prismatique.stem.sim.run` using the PRISM algorithm, with
        originally a basename of the form
        ``"S_matrices_of_subset_"+str(i)+".h5"`` is valid, where ``i`` is a
        nonnegative integer.  
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional 
        The "multidimensional slice object", which specifies the subcollection
        of :math:`S`-matrices to load from file. We define a multi-dimensional
        slice object as a `tuple` of items which contains at most one item being
        a `list` of integers, and the remaining items being `slice` and/or `int`
        objects.

        If ``multi_dim_slice`` is a `tuple` of length 2, then
        ``multi_dim_slice[0]`` specifies a set of atomic configuration indices,
        where each atomic configuration index corresponds to a frozen phonon
        configuration; and ``multi_dim_slice[1]`` specifies a set of
        :math:`\mathbf{k}_{xy}` indices, where each :math:`\mathbf{k}_{xy}`
        index corresponds to a different :math:`\mathbf{k}_{xy}`-momentum vector
        of a plane wave used to calculate a different :math:`S`-matrix. In this
        case, the current Python function will load the :math:`S`-matrices of
        the frozen phonon configurations specified by ``multi_dim_slice[0]``,
        calculated using the plane waves with the
        :math:`\mathbf{k}_{xy}`-momenta vectors specified by
        ``multi_dim_slice[1]``. Note that
        ``prismatique.sample.S_matrix_k_xy_vectors(sample_specification,
        probe_model_params)[multi_dim_slice[1]]` yields the aforementioned
        specified :math:`\mathbf{k}_{xy}`-momenta vectors, where
        ``sample_specification`` and ``probe_model_params`` are objects of the
        appropriate types representing the sample model/model parameters and the
        probe model parameters respectively, used to generate the
        :math:`S`-matrices.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the
        :math:`S`-matrices stored in the file are loaded.

    Returns
    -------
    S_matrix_wavefunction_signal : :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`
        The subcollection of :math:`S`-matrices, stored in an instance of the
        :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D` class.  See
        the documentation and/or reference guide for the :hyperspy:`hyperspy <>`
        package for details on how to use instances of the
        :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D` class.
    navigational_to_original_indices_map : `dict`
        A dictionary that maps the navigational indices of the hyperspy signal
        ``S_matrix_wavefunction_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original atomic configuration
        indices map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["atomic_config_indices"][i]``
        yields the atomic configuration index specified in the expression
        ``single_dim_slice=multi_dim_slice[0] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of
        ``S_matrix_wavefunction_signal``, where ``i`` is a nonnegative integer
        smaller than the total number of atomic configuration indices specified
        in ``single_dim_slice``.

    """
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("atomic_config_indices",
                                   "k_xy_vector_indices"),
              "average_thermally": False,
              "average_laterally_in_space": False,
              "num_superslices": 0,
              "func_to_calc_sizes_of_navigational_space_axes": \
              _sizes_of_navigational_space_axes_for_S_matrix_wavefunctions,
              "func_to_initialize_sample_specification_signal": \
              _initialize_S_matrix_wavefunction_signal}

    S_matrix_wavefunction_signal, navigational_to_original_indices_map = \
        _sample_specification_signal_and_indices_map(**kwargs)

    return S_matrix_wavefunction_signal, navigational_to_original_indices_map



def _sizes_of_navigational_space_axes_for_S_matrix_wavefunctions(filename):
    unformatted_err_msg = \
        _sizes_of_navigational_space_axes_for_S_matrix_wavefunctions_err_msg_1
    
    try:
        kwargs = {"filenames": (filename,)}
        sample_specification = prismatique.sample.SMatrixSubsetIDs(**kwargs)
        accepted_types = (prismatique.sample.SMatrixSubsetIDs,)
        prismatique.sample._check_sample_specification(sample_specification,
                                                       accepted_types)
    except:
        func_name = "prismatique.load.S_matrix_wavefunctions"
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    kwargs = \
        {"sample_specification": sample_specification, "subset_idx": 0}
    num_frozen_phonon_configs_in_subset = \
        prismatique.sample._num_frozen_phonon_configs_in_subset(**kwargs)

    path_in_file = "4DSTEM_simulation/data/realslices/smatrix_fp0000/data"
    dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
    dataset = h5pywrappers.dataset.load(dataset_id)
    num_S_matrix_k_xy_vectors = dataset.shape[2]
    dataset.file.close()

    sizes_of_navigational_space_axes = (num_frozen_phonon_configs_in_subset,
                                        num_S_matrix_k_xy_vectors)

    return sizes_of_navigational_space_axes



def _initialize_S_matrix_wavefunction_signal(filename,
                                             multi_dim_slice,
                                             indices_map,
                                             indices_map_keys,
                                             extra_kwargs):
    kwargs = {"filenames": (filename,)}
    sample_specification = prismatique.sample.SMatrixSubsetIDs(**kwargs)

    N_x, N_y = \
        prismatique.sample._supercell_xy_dims_in_pixels(sample_specification)

    interpolation_factors_from_sample_specification = \
        prismatique.sample._interpolation_factors_from_sample_specification
    f_x, f_y = \
        interpolation_factors_from_sample_specification(sample_specification)

    Delta_x, Delta_y = \
        prismatique.sample._supercell_lateral_pixel_size(sample_specification)

    signal_space_offsets = (-Delta_x * (N_x // 2 // f_x),
                            Delta_y * (N_y // 2 // f_y))

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "signal_space_sizes": (N_x // 2 // f_x, N_y // 2 // f_y),
              "signal_space_scales": (2 * Delta_x, -2 * Delta_y),
              "signal_space_offsets": signal_space_offsets,
              "signal_space_units": ("Å", "Å"),
              "signal_dtype": "complex64",
              "signal_title": "S-Matrix Wavefunction",
              "use_two_axes_to_map_probe_position_if_possible": False,
              "extra_kwargs": extra_kwargs}
    
    S_matrix_wavefunction_signal = \
        _initialize_signal_for_generic_case(**kwargs)

    return S_matrix_wavefunction_signal



def cbed_wavefunctions(filename,
                       multi_dim_slice=None,
                       use_two_axes_to_map_probe_position_if_possible=False):
    r"""From a given STEM simulation output file that stores CBED wavefunction
    patterns, load a specified subcollection of said CBED wavefunction patterns
    into a ``hyperspy`` signal.

    See the documentation for the class :class:`prismatique.cbed.Params` for a
    discussion on CBED wavefunction patterns, which we denote as
    :math:`\left|\psi_{t}\left(\delta_{f};\mathbf{u}_{1}, \ldots,\mathbf{u}_{N};
    \boldsymbol{\delta}_{\beta}\right)\right\rangle` throughout the
    documentation. See also the documentation for the class
    :class:`prismatique.thermal.Params` for additional information and context
    on said patterns.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the CBED
        wavefunction patterns. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run`, with originally a basename of the form
        ``"stem_sim_wavefunction_output_of_subset_"+str(i)+".h5"`` is valid,
        where ``i`` is a nonnegative integer. See the documentation for the
        class :class:`prismatique.stem.output.Params` for a discussion on the
        layout and structuring of ``prismatique`` STEM simulation output files.
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional
        The "multidimensional slice object", which specifies the subcollection
        of CBED wavefunction patterns to load from file. We define a
        multi-dimensional slice object as a `tuple` of items which contains at
        most one item being a `list` of integers, and the remaining items being
        `slice` and/or `int` objects.

        If ``multi_dim_slice`` is a `tuple` of length 4, then then
        ``multi_dim_slice[0]`` specifies a set of output layer indices, where
        each output layer index corresponds to a different output layer;
        ``multi_dim_slice[1]`` specifies a set of atomic configuration indices,
        where each atomic configuration index corresponds to a frozen phonon
        configuration; ``multi_dim_slice[2]`` specifies a set of defocus
        indices, where each defocus index corresponds to a different beam
        defocus; and ``multi_dim_slice[3]`` specifies a set of probe indices,
        where each probe index corresponds to a different probe position. In
        this case, the current Python function will load the CBED wavefunction
        patterns of the frozen phonon configurations specified by
        ``multi_dim_slice[1]``, generated by electrons exiting from the output
        layers specified by ``multi_dim_slice[0]``, the electrons of which
        coming from probes operating at the defocii specified by
        ``multi_dim_slice[2]`` and centered at the positions specified by
        ``multi_dim_slice[3]``. Note that
        ``prismatique.load.output_layer_depths(filename)[multi_dim_slice[0]]``
        yields the depths of the specified output layers;
        ``prismatique.load.defocii(filename)[multi_dim_slice[2]]`` yields the
        specified defocii; and ``prismatique.load.probe_positions(filename,
        force_2_col_shape=True)[multi_dim_slice[3]]`` yields the specified probe
        positions.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the CBED
        wavefunction patterns stored in the file are loaded.
    use_two_axes_to_map_probe_position_if_possible : `bool`, optional
        If ``use_two_axes_to_map_probe_position_if_possible`` is set to
        ``True``, ``prismatique.load.scan_pattern_type(filename) ==
        "rectangular_grid"``, and ``multi_dim_slice`` satisfies either
        ``multi_dim_slice[-1]==slice(None)`` or ``multi_dim_slice is None``,
        then two ``hyperspy`` axes are used rather than one to map the probe
        position. In this case, the two axes have the same dimensions as the
        rectangular grid on which the probe positions lie. Otherwise, one
        ``hyperspy`` axis is used to map the probe positions.

    Returns
    -------
    cbed_wavefunction_signal : :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`
        The subcollection of CBED wavefunction patterns, stored in an instance
        of the :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`
        class.  See the documentation and/or reference guide for the
        :hyperspy:`hyperspy <>` package for details on how to use instances of
        the :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D` class.
    navigational_to_original_indices_map : `dict`
        A dictionary that maps the navigational indices of the hyperspy signal
        ``cbed_wavefunction_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original atomic configuration
        indices map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["atomic_config_indices"][i]``
        yields the atomic configuration index specified in the expression
        ``single_dim_slice=multi_dim_slice[1] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of ``cbed_wavefunction_signal``,
        where ``i`` is a nonnegative integer smaller than the total number of
        atomic configuration indices specified in ``single_dim_slice``.

    """
    func_to_calc_sizes_of_navigational_space_axes = \
        _sizes_of_navigational_space_axes_for_cbed_wavefunctions
    func_to_initialize_cbed_related_signal = \
        _initialize_cbed_wavefunction_signal

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("output_layer_indices",
                                   "atomic_config_indices",
                                   "defocus_indices",
                                   "probe_indices"),
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes,
              "func_to_initialize_cbed_related_signal": \
              func_to_initialize_cbed_related_signal}

    cbed_wavefunction_signal, navigational_to_original_indices_map = \
        _cbed_related_signal_and_indices_map(**kwargs)

    return cbed_wavefunction_signal, navigational_to_original_indices_map



def _sizes_of_navigational_space_axes_for_cbed_wavefunctions(filename):
    try:
        path_in_file = "/data/4D_STEM/complex_valued_DPs"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        sizes_of_navigational_space_axes = dataset.shape[:4]
        dataset.file.close()
    except:
        func_name = \
            "prismatique.load.cbed_wavefunctions"
        unformatted_err_msg = \
            _sizes_of_navigational_space_axes_for_cbed_wavefunctions_err_msg_1
        err_msg = \
            unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return sizes_of_navigational_space_axes



def _initialize_cbed_wavefunction_signal(
        filename,
        multi_dim_slice,
        indices_map,
        indices_map_keys,
        use_two_axes_to_map_probe_position_if_possible):
    k_x = cbed_k_x_coords(filename)
    k_y = cbed_k_y_coords(filename)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "signal_space_sizes": (len(k_x), len(k_y)),
              "signal_space_scales": (k_x[1]-k_x[0], k_y[1]-k_y[0]),
              "signal_space_offsets": (k_x[0], k_y[0]),
              "signal_space_units": ("1/Å", "1/Å"),
              "signal_dtype": "complex64",
              "signal_title": "CBED Wavefunction",
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "extra_kwargs": dict()}
    cbed_wavefunction_signal = _initialize_signal_for_generic_case(**kwargs)

    return cbed_wavefunction_signal



def _cbed_related_signal_and_indices_map(
        filename,
        multi_dim_slice,
        indices_map_keys,
        use_two_axes_to_map_probe_position_if_possible,
        func_to_calc_sizes_of_navigational_space_axes,
        func_to_initialize_cbed_related_signal):
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": indices_map_keys,
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes}
    indices_map, multi_dim_slice = \
        _indices_map_and_converted_multi_dim_slice(**kwargs)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible}
    cbed_related_signal = func_to_initialize_cbed_related_signal(**kwargs)
    
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "cbed_related_signal": cbed_related_signal,
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible}
    _load_data_into_cbed_related_signal(**kwargs)

    kwargs = {"indices_map": indices_map,
              "filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "extra_kwargs": dict()}
    _clean_indices_map(**kwargs)

    return cbed_related_signal, indices_map



def _load_data_into_cbed_related_signal(
        filename,
        multi_dim_slice,
        cbed_related_signal,
        use_two_axes_to_map_probe_position_if_possible):
    path_in_file = _path_in_file_to_cbed_related_data(cbed_related_signal)
    dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
    dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
    dataset_rank = len(dataset.shape)
    signal_space_rank = dataset_rank - len(multi_dim_slice)
    dataset.file.close()

    hdf5_multi_dim_slice = \
        tuple(list(multi_dim_slice) + ([slice(None)]*signal_space_rank))
    
    kwargs = {"dataset_id": dataset_id, "multi_dim_slice": hdf5_multi_dim_slice}
    datasubset_id = h5pywrappers.datasubset.ID(**kwargs)
    try:
        cbed_related_data = h5pywrappers.datasubset.load(datasubset_id)

        kwargs = \
            {"filename": filename,
             "multi_dim_slice": multi_dim_slice,
             "cbed_related_signal": cbed_related_signal,
             "use_two_axes_to_map_probe_position_if_possible": \
             use_two_axes_to_map_probe_position_if_possible}    
        cbed_related_data_is_to_be_transformed = \
            _cbed_related_data_is_to_be_transformed(**kwargs)

        if cbed_related_data_is_to_be_transformed:
            kwargs = {"cbed_related_data": cbed_related_data,
                      "filename": filename,
                      "signal_space_rank": signal_space_rank}
            cbed_related_data = _transform_cbed_related_datasubset(**kwargs)
        
        cbed_related_signal.data = cbed_related_data
    except:
        unformatted_err_msg = _load_data_into_cbed_related_signal_err_msg_1
        err_msg = unformatted_err_msg.format(path_in_file, filename)
        raise IOError(err_msg)

    return None



def _path_in_file_to_cbed_related_data(cbed_related_signal):
    signal_title = cbed_related_signal.metadata.General.title
    if signal_title == "CBED Wavefunction":
        path_in_file = "/data/4D_STEM/complex_valued_DPs"
    elif signal_title == "CBED Intensity Pattern":
        path_in_file = "/data/4D_STEM/intensity_DPs"
    elif signal_title == "Center of Mass Momentum":
        path_in_file = "/data/center_of_mass_momentum"
    elif signal_title == "STEM Intensity Image":
        path_in_file = "/data/2D_STEM/integrated_intensities"
    else:
        path_in_file = "/data/3D_STEM/integrated_intensities"

    return path_in_file



def _cbed_related_data_is_to_be_transformed(
        filename,
        multi_dim_slice,
        cbed_related_signal,
        use_two_axes_to_map_probe_position_if_possible):
    scan_pattern_type = prismatique.load.scan_pattern_type(filename)
    signal_title = cbed_related_signal.metadata.General.title

    if ((signal_title in ("CBED Intensity Pattern", "Center of Mass Momentum"))
        or (multi_dim_slice[-1] == slice(None))):
        data_for_all_probe_positions_is_to_be_loaded = True
    else:
        data_for_all_probe_positions_is_to_be_loaded = False
    
    if ((scan_pattern_type == "rectangular_grid")
        and use_two_axes_to_map_probe_position_if_possible
        and data_for_all_probe_positions_is_to_be_loaded):
        cbed_related_data_is_to_be_transformed = True
    else:
        cbed_related_data_is_to_be_transformed = False

    return cbed_related_data_is_to_be_transformed



def _transform_cbed_related_data(cbed_related_data,
                                 filename,
                                 signal_space_rank):
    new_shape = (list(cbed_related_data.shape[:-(signal_space_rank+1)])
                 + list(grid_dims_in_units_of_probe_shifts(filename))
                 + list(cbed_related_data.shape[-signal_space_rank:]))
        
    new_axes_order = \
        list(range(len(new_shape)))
    new_axes_order[[-(signal_space_rank+1), -(signal_space_rank+2)]] = \
        new_axes_order[[-(signal_space_rank+2), -(signal_space_rank+1)]]
        
    np_multi_dim_slice = [slice(None)]*len(new_shape)
    np_multi_dim_slice[-(signal_space_rank+2)] = slice(None, None, -1)
    np_multi_dim_slice = tuple(np_multi_dim_slice)
        
    cbed_related_data = np.transpose(cbed_related_data.reshape(new_shape),
                                     axes=new_axes_order)[np_multi_dim_slice]

    return cbed_related_data



def cbed_intensity_patterns(
        filename,
        multi_dim_slice=None,
        use_two_axes_to_map_probe_position_if_possible=False):
    r"""From a given STEM simulation output file that stores CBED intensity
    patterns, load a specified subcollection of said CBED intensity patterns
    into a ``hyperspy`` signal.

    See the documentation for the class :class:`prismatique.cbed.Params` for a
    discussion on CBED intensity patterns

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the CBED intensity
        patterns. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run`, with originally the basename
        ``"stem_sim_intensity_output.h5"`` is valid. See the documentation for
        the class :class:`prismatique.stem.output.Params` for a discussion on
        the layout and structuring of ``prismatique`` STEM simulation output
        files.
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional
        The "multidimensional slice object", which specifies the subcollection
        of CBED intensity patterns to load from file. We define a
        multi-dimensional slice object as a `tuple` of items which contains at
        most one item being a `list` of integers, and the remaining items being
        `slice` and/or `int` objects.

        If ``multi_dim_slice`` is a `tuple` of length 2, then then
        ``multi_dim_slice[0]`` specifies a set of output layer indices, where
        each output layer index corresponds to a different output layer; and
        ``multi_dim_slice[1]`` specifies a set of probe indices, where each
        probe index corresponds to a different probe position. In this case, the
        current Python function will load the CBED intensity patterns generated
        by electrons exiting from the output layers specified by
        ``multi_dim_slice[0]``, the electrons of which coming from probes
        centered at the positions specified by ``multi_dim_slice[1]``. Note that
        ``prismatique.load.output_layer_depths(filename)[multi_dim_slice[0]]``
        yields the depths of the specified output layers; and
        ``prismatique.load.probe_positions(filename)[multi_dim_slice[1]]``
        yields the specified probe positions.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the CBED
        intensity patterns stored in the file are loaded.
    use_two_axes_to_map_probe_position_if_possible : `bool`, optional
        If ``use_two_axes_to_map_probe_position_if_possible`` is set to
        ``True``, ``prismatique.load.scan_pattern_type(filename) ==
        "rectangular_grid"``, and ``multi_dim_slice`` satisfies either
        ``multi_dim_slice[-1]==slice(None)`` or ``multi_dim_slice is None``,
        then two ``hyperspy`` axes are used rather than one to map the probe
        position. In this case, the two axes have the same dimensions as the
        rectangular grid on which the probe positions lie. Otherwise, one
        ``hyperspy`` axis is used to map the probe positions.

    Returns
    -------
    cbed_intensity_pattern_signal : :class:`hyperspy._signals.signal2d.Signal2D`
        The subcollection of CBED intensity patterns, stored in an instance of
        the :class:`hyperspy._signals.signal2d.Signal2D` class.  See the
        documentation and/or reference guide for the :hyperspy:`hyperspy <>`
        package for details on how to use instances of the
        :class:`hyperspy._signals.signal2d.Signal2D` class.
    navigational_to_original_indices_map : `dict`
        A dictionary that maps the navigational indices of the hyperspy signal
        ``cbed_intensity_pattern_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original output layer indices
        indices map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["output_layer_indices"][i]``
        yields the output layer index specified in the expression
        ``single_dim_slice=multi_dim_slice[0] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of
        ``cbed_intensity_pattern_signal``, where ``i`` is a nonnegative integer
        smaller than the total number of output layers specified in
        ``single_dim_slice``.

    """
    func_to_calc_sizes_of_navigational_space_axes = \
        _sizes_of_navigational_space_axes_for_cbed_intensity_patterns
    func_to_initialize_cbed_related_signal = \
        _initialize_cbed_intensity_pattern_signal

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("output_layer_indices", "probe_indices"),
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes,
              "func_to_initialize_cbed_related_signal": \
              func_to_initialize_cbed_related_signal}

    cbed_intensity_pattern_signal, navigational_to_original_indices_map = \
        _cbed_related_signal_and_indices_map(**kwargs)

    return cbed_intensity_pattern_signal, navigational_to_original_indices_map



def _sizes_of_navigational_space_axes_for_cbed_intensity_patterns(filename):
    unformatted_err_msg = \
        _sizes_of_navigational_space_axes_for_cbed_intensity_patterns_err_msg_1
    
    try:
        path_in_file = "/data/4D_STEM/intensity_DPs"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        sizes_of_navigational_space_axes = dataset.shape[:2]
        dataset.file.close()
    except:
        func_name = "prismatique.load.cbed_intensity_patterns"
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return sizes_of_navigational_space_axes



def _initialize_cbed_intensity_pattern_signal(
        filename,
        multi_dim_slice,
        indices_map,
        indices_map_keys,
        use_two_axes_to_map_probe_position_if_possible):
    k_x = cbed_k_x_coords(filename)
    k_y = cbed_k_y_coords(filename)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "signal_space_sizes": (len(k_x), len(k_y)),
              "signal_space_scales": (k_x[1]-k_x[0], k_y[1]-k_y[0]),
              "signal_space_offsets": (k_x[0], k_y[0]),
              "signal_space_units": ("1/Å", "1/Å"),
              "signal_dtype": "float32",
              "signal_title": "CBED Intensity Pattern",
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "extra_kwargs": dict()}
    
    cbed_intensity_pattern_signal = \
        _initialize_signal_for_generic_case(**kwargs)

    return cbed_intensity_pattern_signal



def com_momenta(filename,
                multi_dim_slice=None,
                use_two_axes_to_map_probe_position_if_possible=False):
    r"""From a given STEM simulation output file that stores center of mass 
    (COM) momentum patterns, load a specified subcollection of said COM momentum
    patterns into a ``hyperspy`` signal.

    See the documentation for the class :class:`prismatique.stem.output.Params`
    for a discussion on COM momentum patterns.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the COM momentum
        patterns. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run`, with originally the basename
        ``"stem_sim_intensity_output.h5"`` is valid. See the documentation for
        the class :class:`prismatique.stem.output.Params` for a discussion on
        the layout and structuring of ``prismatique`` STEM simulation output
        files.
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional
        The "multidimensional slice object", which specifies the subcollection
        of COM momentum patterns to load from file. We define a
        multi-dimensional slice object as a `tuple` of items which contains at
        most one item being a `list` of integers, and the remaining items being
        `slice` and/or `int` objects.

        If ``multi_dim_slice`` is a `tuple` of length 2, then then
        ``multi_dim_slice[0]`` specifies a set of output layer indices, where
        each output layer index corresponds to a different output layer; and
        ``multi_dim_slice[1]`` specifies the vector component indices, where the
        indices ``0`` and ``1`` would correspond to the :math:`x`- and
        :math:`y`-components of the COM momentum respectively. In this case, the
        current Python function will load the COM momentum patterns generated by
        electrons exiting from the output layers specified by
        ``multi_dim_slice[0]``, for the vector components specified by
        ``multi_dim_slice[1]``. Note that
        ``prismatique.load.output_layer_depths(filename)[multi_dim_slice[0]]``
        yields the depths of the specified output layers.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the COM
        momentum patterns stored in the file are loaded.
    use_two_axes_to_map_probe_position_if_possible : `bool`, optional
        If ``use_two_axes_to_map_probe_position_if_possible`` is set to
        ``True``, and ``prismatique.load.scan_pattern_type(filename) ==
        "rectangular_grid"``, then two ``hyperspy`` axes are used rather than
        one to map the probe position. In this case, the two axes have the same
        dimensions as the rectangular grid on which the probe positions
        lie. Otherwise, one ``hyperspy`` axis is used to map the probe
        positions.

    Returns
    -------
    com_momentum_signal : :class:`hyperspy._signals.signal2d.Signal2D`
        The subcollection of COM momentum patterns, stored in a ``hyperspy``
        signal: If two axes are used to map the probe position, then the STEM
        intensity images are stored in an instance of the
        :class:`hyperspy._signals.signal2d.Signal2D` class; otherwise they are
        stored in an instance of the
        :class:`hyperspy._signals.signal1d.Signal1D` class. See the
        documentation and/or reference guide for the :hyperspy:`hyperspy <>`
        package for details on how to use instances of the
        :class:`hyperspy._signals.signal1d.Signal1D` and
        :class:`hyperspy._signals.signal2d.Signal2D` classes.
    navigational_to_original_indices_map : `dict`        
        A dictionary that maps the navigational indices of the hyperspy signal
        ``com_momentum_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original output layer indices
        indices map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["output_layer_indices"][i]``
        yields the output layer index specified in the expression
        ``single_dim_slice=multi_dim_slice[0] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of ``com_momentum_signal``, where
        ``i`` is a nonnegative integer smaller than the total number of output
        layers specified in ``single_dim_slice``.

    """
    func_to_calc_sizes_of_navigational_space_axes = \
        _sizes_of_navigational_space_axes_for_com_momenta
    func_to_initialize_cbed_related_signal = \
        _initialize_com_momentum_signal

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("output_layer_indices",
                                   "vector_component_indices"),
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes,
              "func_to_initialize_cbed_related_signal": \
              func_to_initialize_cbed_related_signal}

    com_momentum_signal, navigational_to_original_indices_map = \
        _cbed_related_signal_and_indices_map(**kwargs)

    return com_momentum_signal, navigational_to_original_indices_map



def _sizes_of_navigational_space_axes_for_com_momenta(filename):
    try:
        path_in_file = "/data/center_of_mass_momentum"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        sizes_of_navigational_space_axes = dataset.shape[:2]
        dataset.file.close()
    except:
        func_name = \
            "prismatique.load.com_momenta"
        unformatted_err_msg = \
            _sizes_of_navigational_space_axes_for_com_momenta_err_msg_1
        err_msg = \
            unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return sizes_of_navigational_space_axes



def _initialize_com_momentum_signal(
        filename,
        multi_dim_slice,
        indices_map,
        indices_map_keys,
        use_two_axes_to_map_probe_position_if_possible):
    kwargs = \
        {"filename": filename,
         "use_two_axes_to_map_probe_position_if_possible": \
         use_two_axes_to_map_probe_position_if_possible}
    signal_space_axes_properties = \
        _signal_space_axes_properties_for_com_momenta_or_stem_images(**kwargs)

    kwargs.update(signal_space_axes_properties)
    kwargs["multi_dim_slice"] = multi_dim_slice
    kwargs["indices_map"] = indices_map
    kwargs["indices_map_keys"] = indices_map_keys
    kwargs["signal_dtype"] = "float32"
    kwargs["signal_title"] = "Center of Mass Momentum"
    kwargs["extra_kwargs"] = dict()
    com_momentum_signal = _initialize_signal_for_generic_case(**kwargs)

    return com_momentum_signal



def _signal_space_axes_properties_for_com_momenta_or_stem_images(
        filename, use_two_axes_to_map_probe_position_if_possible):
    scan_pattern_type = prismatique.load.scan_pattern_type(filename)
    if ((scan_pattern_type == "rectangular_grid")
        and (use_two_axes_to_map_probe_position_if_possible)):
        stem_probe_positions = probe_positions(filename,
                                               force_2_col_shape=False)
        Y_dim, X_dim, _ = stem_probe_positions.shape
        dr_x = stem_probe_positions[0, 1, 0] - stem_probe_positions[0, 0, 0]
        dr_y = stem_probe_positions[0, 0, 1] - stem_probe_positions[1, 0, 1]
        signal_space_sizes = (X_dim, Y_dim)
        signal_space_scales = (dr_x, -dr_y)
        signal_space_offsets = (stem_probe_positions[0, 0, 0],
                                stem_probe_positions[0, 0, 1])
        signal_space_units = ("Å", "Å")
    else:
        stem_probe_positions = probe_positions(filename, force_2_col_shape=True)
        signal_space_sizes = (len(stem_probe_positions),)
        signal_space_scales = (1,)
        signal_space_offsets = (0,)
        signal_space_units = ("dimensionless",)

    signal_space_axes_properties = \
        {"signal_space_sizes": signal_space_sizes,
         "signal_space_scales": signal_space_scales,
         "signal_space_offsets": signal_space_offsets,
         "signal_space_units": signal_space_units}

    return signal_space_axes_properties



def stem_intensity_images(filename,
                          multi_dim_slice=None,
                          use_two_axes_to_map_probe_position_if_possible=False):
    r"""From a given STEM simulation output file that stores STEM intensity 
    images, load a specified subcollection of said STEM intensity images into a 
    ``hyperspy`` signal.

    See the documentation for the class :class:`prismatique.stem.output.Params`
    for a discussion on STEM intensity images, i.e. 2D-STEM output.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the STEM intensity
        images. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run`, with originally the basename
        ``"stem_sim_intensity_output.h5"`` is valid. See the documentation for
        the class :class:`prismatique.stem.output.Params` for a discussion on
        the layout and structuring of ``prismatique`` STEM simulation output
        files.
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional
        The "multidimensional slice object", which specifies the subcollection
        of STEM intensity images to load from file. We define a
        multi-dimensional slice object as a `tuple` of items which contains at
        most one item being a `list` of integers, and the remaining items being
        `slice` and/or `int` objects.

        If ``multi_dim_slice`` is a `tuple` of length 1, then then
        ``multi_dim_slice[0]`` specifies a set of output layer indices, where
        each output layer index corresponds to a different output layer. In this
        case, the current Python function will load the STEM intensity images
        generated by electrons exiting from the output layers specified by
        ``multi_dim_slice[0]``. Note that
        ``prismatique.load.output_layer_depths(filename)[multi_dim_slice[0]]``
        yields the depths of the specified output layers.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the STEM
        intensity images stored in the file are loaded.
    use_two_axes_to_map_probe_position_if_possible : `bool`, optional
        If ``use_two_axes_to_map_probe_position_if_possible`` is set to
        ``True``, and ``prismatique.load.scan_pattern_type(filename) ==
        "rectangular_grid"``, then two ``hyperspy`` axes are used rather than
        one to map the probe position. In this case, the two axes have the same
        dimensions as the rectangular grid on which the probe positions
        lie. Otherwise, one ``hyperspy`` axis is used to map the probe
        positions.

    Returns
    -------
    stem_image_signal : :class:`hyperspy._signals.signal1d.Signal1D` | :class:`hyperspy._signals.signal2d.Signal2D`
        The subcollection of STEM intensity images, stored in a ``hyperspy``
        signal: If two axes are used to map the probe position, then the STEM
        intensity images are stored in an instance of the
        :class:`hyperspy._signals.signal2d.Signal2D` class; otherwise they are
        stored in an instance of the
        :class:`hyperspy._signals.signal1d.Signal1D` class. See the
        documentation and/or reference guide for the :hyperspy:`hyperspy <>`
        package for details on how to use instances of the
        :class:`hyperspy._signals.signal1d.Signal1D` and
        :class:`hyperspy._signals.signal2d.Signal2D` classes.
    navigational_to_original_indices_map : `dict`
        A dictionary that maps the navigational indices of the hyperspy signal
        ``stem_image_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original output layer indices
        map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["output_layer_indices"][i]``
        yields the output layer index specified in the expression
        ``single_dim_slice=multi_dim_slice[0] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of ``stem_image_signal``, where
        ``i`` is a nonnegative integer smaller than the total number of output
        layer indices specified in ``single_dim_slice``.

    """
    func_to_calc_sizes_of_navigational_space_axes = \
        _sizes_of_navigational_space_axes_for_stem_images
    func_to_initialize_cbed_related_signal = \
        _initialize_stem_image_signal

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("output_layer_indices",),
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes,
              "func_to_initialize_cbed_related_signal": \
              func_to_initialize_cbed_related_signal}

    stem_image_signal, navigational_to_original_indices_map = \
        _cbed_related_signal_and_indices_map(**kwargs)

    return stem_image_signal, navigational_to_original_indices_map



def _sizes_of_navigational_space_axes_for_stem_images(filename):
    try:
        path_in_file = "/data/2D_STEM/integrated_intensities"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        sizes_of_navigational_space_axes = dataset.shape[:1]
        dataset.file.close()
    except:
        func_name = \
            "prismatique.load.stem_intensity_images"
        unformatted_err_msg = \
            _sizes_of_navigational_space_axes_for_stem_images_err_msg_1
        err_msg = \
            unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return sizes_of_navigational_space_axes



def _initialize_stem_image_signal(
        filename,
        multi_dim_slice,
        indices_map,
        indices_map_keys,
        use_two_axes_to_map_probe_position_if_possible):
    kwargs = \
        {"filename": filename,
         "use_two_axes_to_map_probe_position_if_possible": \
         use_two_axes_to_map_probe_position_if_possible}
    signal_space_axes_properties = \
        _signal_space_axes_properties_for_com_momenta_or_stem_images(**kwargs)

    kwargs.update(signal_space_axes_properties)
    kwargs["multi_dim_slice"] = multi_dim_slice
    kwargs["indices_map"] = indices_map
    kwargs["indices_map_keys"] = indices_map_keys
    kwargs["signal_dtype"] = "float32"
    kwargs["signal_title"] = "STEM Intensity Image"
    kwargs["extra_kwargs"] = dict()
    stem_image_signal = _initialize_signal_for_generic_case(**kwargs)

    return stem_image_signal



def azimuthally_integrated_cbed_intensity_patterns(
        filename,
        multi_dim_slice=None,
        use_two_axes_to_map_probe_position_if_possible=False):
    r"""From a given STEM simulation output file that stores azimuthally 
    integrated CBED intensity patterns, load a specified subcollection of said 
    integrated intensity patterns into a ``hyperspy`` signal.

    See the documentation for the class :class:`prismatique.stem.output.Params`
    for a discussion on azimuthally integrated CBED intensity patterns, i.e.
    3D-STEM output.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the azimuthally
        integrated CBED intensity patterns. Any non-temporary file generated by
        the function :func:`prismatique.stem.sim.run`, with originally the
        basename ``"stem_sim_intensity_output.h5"`` is valid. See the
        documentation for the class :class:`prismatique.stem.output.Params` for
        a discussion on the layout and structuring of ``prismatique`` STEM
        simulation output files.
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional
        The "multidimensional slice object", which specifies the subcollection
        of azimuthally integrated CBED intensity patterns to load from file. We
        define a multi-dimensional slice object as a `tuple` of items which
        contains at most one item being a `list` of integers, and the remaining
        items being `slice` and/or `int` objects.

        If ``multi_dim_slice`` is a `tuple` of length 2, then then
        ``multi_dim_slice[0]`` specifies a set of output layer indices, where
        each output layer index corresponds to a different output layer; and
        ``multi_dim_slice[1]`` specifies a set of probe indices, where each
        probe index corresponds to a different probe position. In this case, the
        current Python function will load the azimuthally integrated CBED
        intensity patterns generated by electrons exiting from the output layers
        specified by ``multi_dim_slice[0]``, the electrons of which coming from
        probes centered at the positions specified by
        ``multi_dim_slice[1]``. Note that
        ``prismatique.load.output_layer_depths(filename)[multi_dim_slice[0]]``
        yields the depths of the specified output layers; and
        ``prismatique.load.probe_positions(filename)[multi_dim_slice[1]]``
        yields the specified probe positions.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the
        azimuthally integrated CBED intensity patterns stored in the file are
        loaded.
    use_two_axes_to_map_probe_position_if_possible : `bool`, optional
        If ``use_two_axes_to_map_probe_position_if_possible`` is set to
        ``True``, and ``prismatique.load.scan_pattern_type(filename) ==
        "rectangular_grid"``, then two ``hyperspy`` axes are used rather than
        one to map the probe position. In this case, the two axes have the same
        dimensions as the rectangular grid on which the probe positions
        lie. Otherwise, one ``hyperspy`` axis is used to map the probe
        positions.

    Returns
    -------
    intensity_3d_stem_signal : :class:`hyperspy._signals.signal2d.Signal2D`
        The subcollection of azimuthally integrated CBED intensity patterns,
        stored in an instance of the
        :class:`hyperspy._signals.signal2d.Signal2D` class.  See the
        documentation and/or reference guide for the :hyperspy:`hyperspy <>`
        package for details on how to use instances of the
        :class:`hyperspy._signals.signal2d.Signal2D` class.
    navigational_to_original_indices_map : `dict`
        A dictionary that maps the navigational indices of the hyperspy signal
        ``intensity_3d_stem_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original output layer indices
        map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["output_layer_indices"][i]``
        yields the output layer index specified in the expression
        ``single_dim_slice=multi_dim_slice[0] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of ``intensity_3d_stem_signal``,
        where ``i`` is a nonnegative integer smaller than the total number of
        output layer indices specified in ``single_dim_slice``.

    """
    func_to_calc_sizes_of_navigational_space_axes = \
        _sizes_of_navigational_space_axes_for_intensity_3d_stem
    func_to_initialize_cbed_related_signal = \
        _initialize_intensity_3d_stem_signal

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("output_layer_indices", "probe_indices"),
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes,
              "func_to_initialize_cbed_related_signal": \
              func_to_initialize_cbed_related_signal}

    intensity_3d_stem_signal, navigational_to_original_indices_map = \
        _cbed_related_signal_and_indices_map(**kwargs)

    return intensity_3d_stem_signal, navigational_to_original_indices_map



def _sizes_of_navigational_space_axes_for_intensity_3d_stem(filename):
    try:
        path_in_file = "/data/3D_STEM/integrated_intensities"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        sizes_of_navigational_space_axes = dataset.shape[:2]
        dataset.file.close()
    except:
        func_name = \
            "prismatique.load.azimuthally_integrated_cbed_intensity_patterns"
        unformatted_err_msg = \
            _sizes_of_navigational_space_axes_for_intensity_3d_stem_err_msg_1
        err_msg = \
            unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return sizes_of_navigational_space_axes



def _initialize_intensity_3d_stem_signal(
        filename,
        multi_dim_slice,
        indices_map,
        indices_map_keys,
        use_two_axes_to_map_probe_position_if_possible):
    k_xy = k_xy_coords_of_3d_stem_output(filename)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "signal_space_sizes": (len(k_xy),),
              "signal_space_scales": (k_xy[1]-k_xy[0],),
              "signal_space_offsets": (0,),
              "signal_space_units": ("1/Å",),
              "signal_dtype": "float32",
              "signal_title": "Azimuthally Integrated CBED Intensity Pattern",
              "use_two_axes_to_map_probe_position_if_possible": \
              use_two_axes_to_map_probe_position_if_possible,
              "extra_kwargs": dict()}
    intensity_3d_stem_signal = _initialize_signal_for_generic_case(**kwargs)

    return intensity_3d_stem_signal



def hrtem_image_wavefunctions(filename, multi_dim_slice=None):
    r"""From a given HRTEM simulation output file that stores HRTEM image
    wavefunctions, load a specified subcollection of said HRTEM wavefunctions
    into a ``hyperspy`` signal.

    See the documentation for the class :class:`prismatique.hrtem.image.Params`
    for a discussion on HRTEM image wavefunctions, which we denote as
    :math:`\left|\psi_{t}\left(\delta_{f};\mathbf{u}_{1}, \ldots,\mathbf{u}_{N};
    \boldsymbol{\delta}_{\beta}\right)\right\rangle` throughout the
    documentation. See also the documentation for the class
    :class:`prismatique.thermal.Params` for additional information and context
    on said patterns.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the HRTEM image
        wavefunctions. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run`, with originally a basename of the form
        ``"hrtem_sim_wavefunction_output_of_subset_"+str(i)+".h5"`` is valid,
        where ``i`` is a nonnegative integer. See the documentation for the
        class :class:`prismatique.hrtem.output.Params` for a discussion on the
        layout and structuring of ``prismatique`` HRTEM simulation output files.
    multi_dim_slice : `tuple` (`int` | `slice` | `list` (`int`)) | `None`, optional
        The "multidimensional slice object", which specifies the subcollection
        of HRTEM image wavefunctions to load from file. We define a
        multi-dimensional slice object as a `tuple` of items which contains at
        most one item being a `list` of integers, and the remaining items being
        `slice` and/or `int` objects.

        If ``multi_dim_slice`` is a `tuple` of length 3, then then
        ``multi_dim_slice[0]`` specifies a set of atomic configuration indices,
        where each atomic configuration index corresponds to a frozen phonon
        configuration; ``multi_dim_slice[1]`` specifies a set of defocus
        indices, where each defocus index corresponds to a different beam
        defocus; and ``multi_dim_slice[2]`` specifies a set of tilt indices,
        where each tilt index corresponds to a different beam tilt. In this
        case, the current Python function will load the HRTEM image
        wavefunctions of the frozen phonon configurations specified by
        ``multi_dim_slice[0]``, generated by electron beams operating at the
        defocii specified by ``multi_dim_slice[1]``, and beam tilts specified by
        ``multi_dim_slice[2]``. Note that
        ``prismatique.load.defocii(filename)[multi_dim_slice[1]]`` yields the
        specified defocii; and
        ``prismatique.load.hrtem_beam_tilts(filename)[multi_dim_slice[2]]``
        yields the specified tilts.

        Otherwise, if ``multi_dim_slice`` is set to `None`, then all the HRTEM
        image wavefunctions stored in the file are loaded.

    Returns
    -------
    hrtem_image_wavefunction_signal : :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D`
        The subcollection of HRTEM image wavefunctions, stored in an instance of
        the :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D` class.
        See the documentation and/or reference guide for the :hyperspy:`hyperspy
        <>` package for details on how to use instances of the
        :class:`hyperspy._signals.complex_signal2d.ComplexSignal2D` class.
    navigational_to_original_indices_map : `dict`
        A dictionary that maps the navigational indices of the hyperspy signal
        ``hrtem_image_wavefunction_signal`` to the original indices specified by
        ``multi_dim_slice``. For example, if the original atomic configuration
        indices map to a set of corresponding navigational indices, then
        ``navigational_to_original_indices_map["output_layer_indices"][i]``
        yields the atomic configuration index specified in the expression
        ``single_dim_slice=multi_dim_slice[0] if multi_dim_slice is not None
        else slice(None)`` that corresponds to the ``i`` th atomic configuration
        index in the nagivation index space of
        ``hrtem_image_wavefunction_signal``, where ``i`` is a nonnegative
        integer smaller than the total number of atomic configuration indices
        specified in ``single_dim_slice``.

    """
    func_to_calc_sizes_of_navigational_space_axes = \
        _sizes_of_navigational_space_axes_for_hrtem_wavefunctions
    func_to_initialize_hrtem_related_signal = \
        _initialize_hrtem_image_wavefunction_signal

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": ("atomic_config_indices",
                                   "defocus_indices",
                                   "tilt_indices"),
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes,
              "func_to_initialize_hrtem_related_signal": \
              func_to_initialize_hrtem_related_signal}

    hrtem_image_wavefunction_signal, navigational_to_original_indices_map = \
        _hrtem_related_signal_and_indices_map(**kwargs)

    return (hrtem_image_wavefunction_signal,
            navigational_to_original_indices_map)



def _sizes_of_navigational_space_axes_for_hrtem_wavefunctions(filename):
    unformatted_err_msg = \
        _sizes_of_navigational_space_axes_for_hrtem_wavefunctions_err_msg_1
    
    try:
        path_in_file = "/data/image_wavefunctions"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        sizes_of_navigational_space_axes = dataset.shape[:3]
        dataset.file.close()
    except:
        func_name = "prismatique.load.hrtem_image_wavefunctions"
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return sizes_of_navigational_space_axes



def _initialize_hrtem_image_wavefunction_signal(filename,
                                                multi_dim_slice,
                                                indices_map,
                                                indices_map_keys):
    r_x = hrtem_image_x_coords(filename)
    r_y = hrtem_image_y_coords(filename)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "signal_space_sizes": (len(r_x), len(r_y)),
              "signal_space_scales": (r_x[1]-r_x[0], r_y[1]-r_y[0]),
              "signal_space_offsets": (r_x[0], r_y[0]),
              "signal_space_units": ("Å", "Å"),
              "signal_dtype": "complex64",
              "signal_title": "HRTEM Image Wavefunction",
              "use_two_axes_to_map_probe_position_if_possible": False,
              "extra_kwargs": dict()}
    
    hrtem_image_wavefunction_signal = \
        _initialize_signal_for_generic_case(**kwargs)

    return hrtem_image_wavefunction_signal



def _hrtem_related_signal_and_indices_map(
        filename,
        multi_dim_slice,
        indices_map_keys,
        func_to_calc_sizes_of_navigational_space_axes,
        func_to_initialize_hrtem_related_signal):
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map_keys": indices_map_keys,
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes}
    indices_map, multi_dim_slice = \
        _indices_map_and_converted_multi_dim_slice(**kwargs)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys}
    hrtem_related_signal = func_to_initialize_hrtem_related_signal(**kwargs)
    
    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "hrtem_related_signal": hrtem_related_signal}
    _load_data_into_hrtem_related_signal(**kwargs)

    kwargs = {"indices_map": indices_map,
              "filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "use_two_axes_to_map_probe_position_if_possible": False,
              "extra_kwargs": dict()}
    _clean_indices_map(**kwargs)

    return hrtem_related_signal, indices_map



def _load_data_into_hrtem_related_signal(filename,
                                         multi_dim_slice,
                                         hrtem_related_signal):
    path_in_file = _path_in_file_to_hrtem_related_data(hrtem_related_signal)
    dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
    dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
    dataset_rank = len(dataset.shape)
    signal_space_rank = dataset_rank - len(multi_dim_slice)
    dataset.file.close()

    hdf5_multi_dim_slice = \
        tuple(list(multi_dim_slice) + ([slice(None)]*signal_space_rank))
    
    kwargs = {"dataset_id": dataset_id, "multi_dim_slice": hdf5_multi_dim_slice}
    datasubset_id = h5pywrappers.datasubset.ID(**kwargs)
    try:
        hrtem_related_signal.data = h5pywrappers.datasubset.load(datasubset_id)
    except:
        unformatted_err_msg = _load_data_into_hrtem_related_signal_err_msg_1
        err_msg = unformatted_err_msg.format(path_in_file, filename)
        raise IOError(err_msg)

    return None



def _path_in_file_to_hrtem_related_data(cbed_related_signal):
    signal_title = cbed_related_signal.metadata.General.title
    if signal_title == "HRTEM Image Wavefunction":
        path_in_file = "/data/image_wavefunctions"
    else:
        path_in_file = "/data/intensity_image"

    return path_in_file



def hrtem_intensity_image(filename):
    r"""From a given HRTEM simulation output file that stores an HRTEM intensity
    image, load said HRTEM intensity image into a ``hyperspy`` signal.

    See the documentation for the class :class:`prismatique.hrtem.image.Params`
    for a discussion on HRTEM intensity images.

    Parameters
    ----------
    filename : `str`
        The relative or absolute path to the file containing the HRTEM intensity
        image. Any non-temporary file generated by the function
        :func:`prismatique.stem.sim.run`, with originally the basename
        ``"hrtem_sim_intensity_output.h5"`` is valid, where ``i`` is a
        nonnegative integer. See the documentation for the class
        :class:`prismatique.hrtem.output.Params` for a discussion on the layout
        and structuring of ``prismatique`` HRTEM simulation output files.

    Returns
    -------
    hrtem_intensity_image_signal : :class:`hyperspy._signals.signal2d.Signal2D`
        The HRTEM intensity image, stored in an instance of the
        :class:`hyperspy._signals.signal2d.Signal2D` class.  See the
        documentation and/or reference guide for the :hyperspy:`hyperspy <>`
        package for details on how to use instances of the
        :class:`hyperspy._signals.signal2d.Signal2D` class.

    """
    func_to_calc_sizes_of_navigational_space_axes = \
        _sizes_of_navigational_space_axes_for_hrtem_intensities
    func_to_initialize_hrtem_related_signal = \
        _initialize_hrtem_intensity_image_signal

    kwargs = {"filename": filename,
              "multi_dim_slice": tuple(),
              "indices_map_keys": tuple(),
              "func_to_calc_sizes_of_navigational_space_axes": \
              func_to_calc_sizes_of_navigational_space_axes,
              "func_to_initialize_hrtem_related_signal": \
              func_to_initialize_hrtem_related_signal}

    hrtem_intensity_image_signal, _ = \
        _hrtem_related_signal_and_indices_map(**kwargs)

    return hrtem_intensity_image_signal



def _sizes_of_navigational_space_axes_for_hrtem_intensities(filename):
    unformatted_err_msg = \
        _sizes_of_navigational_space_axes_for_hrtem_intensities_err_msg_1
    
    try:
        path_in_file = "/data/intensity_image"
        dataset_id = h5pywrappers.obj.ID(filename, path_in_file)
        dataset = h5pywrappers.dataset.load(dataset_id, read_only=True)
        sizes_of_navigational_space_axes = dataset.shape[:0]
        dataset.file.close()
    except:
        func_name = "prismatique.load.hrtem_intensity_image"
        err_msg = unformatted_err_msg.format(filename, func_name)
        raise IOError(err_msg)

    return sizes_of_navigational_space_axes



def _initialize_hrtem_intensity_image_signal(filename,
                                             multi_dim_slice,
                                             indices_map,
                                             indices_map_keys):
    r_x = hrtem_image_x_coords(filename)
    r_y = hrtem_image_y_coords(filename)

    kwargs = {"filename": filename,
              "multi_dim_slice": multi_dim_slice,
              "indices_map": indices_map,
              "indices_map_keys": indices_map_keys,
              "signal_space_sizes": (len(r_x), len(r_y)),
              "signal_space_scales": (r_x[1]-r_x[0], r_y[1]-r_y[0]),
              "signal_space_offsets": (r_x[0], r_y[0]),
              "signal_space_units": ("Å", "Å"),
              "signal_dtype": "float32",
              "signal_title": "HRTEM Intensity Image",
              "use_two_axes_to_map_probe_position_if_possible": False,
              "extra_kwargs": dict()}
    
    hrtem_intensity_image_signal = _initialize_signal_for_generic_case(**kwargs)

    return hrtem_intensity_image_signal



###########################
## Define error messages ##
###########################

_scan_pattern_type_err_msg_1 = \
    ("The object ``filename``, which stores the string ``'{}'``, specifies an "
     "invalid filename: see the traceback for details and consult the "
     "documentation for the function `{}`.")

_grid_dims_in_units_of_probe_shifts_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_probe_positions_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_output_layer_depths_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_defocii_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_num_slices_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_num_frozen_phonon_configs_in_subset_err_msg_1 = \
    ("The HDF5 file ``'{}'`` does not store a dataset with the appropriate "
     "dimensions at the HDF5 path '/data/4D_STEM/complex_valued_DPs', nor the "
     "HDF5 path '/data/image_wavefunctions'.")
_num_frozen_phonon_configs_in_subset_err_msg_2 = \
    _scan_pattern_type_err_msg_1

_cbed_k_x_coords_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_cbed_k_y_coords_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_k_xy_coords_of_3d_stem_output_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_integration_limits_of_2d_stem_output_err_msg_1 = \
    ("The loaded integration limits ``integration_limits`` must satisfy "
     "``integration_limits[0] <= integration_limits[1]``.")
_integration_limits_of_2d_stem_output_err_msg_2 = \
    _scan_pattern_type_err_msg_1

_S_matrix_k_xy_vectors_err_msg_1 = \
    ("The file ``'{}'`` stores the parameters for a STEM simulation using the "
     "multislice algorithm, rather than the PRISM algorithm.")
_S_matrix_k_xy_vectors_err_msg_2 = \
    _scan_pattern_type_err_msg_1

_hrtem_beam_tilts_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_hrtem_image_x_coords_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_hrtem_image_y_coords_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_sizes_of_navigational_space_axes_for_potential_slices_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_indices_map_err_msg_1 = \
    ("The object ``multi_dim_slice[{}]`` specifies a single-dimensional slice "
     "that contains at least one index that is out of bounds: the "
     "corresponding data axis is of size {}.")
_indices_map_err_msg_2 = \
    ("The object ``multi_dim_slice[{}]`` specifies a single-dimensional slice "
     "that contains repeating indices after converting any negative indices to "
     "their functionally equivalent positive values.")

_check_multi_dim_slice_length_err_msg_1 = \
    ("The object ``multi_dim_slice`` must be of type `NoneType` or a "
     "'multidimensional slice object' represented as a sequence that satisfies "
     "``len(multi_dim_slice)=={}``.")

_sizes_of_navigational_space_axes_for_S_matrix_wavefunctions_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_sizes_of_navigational_space_axes_for_cbed_wavefunctions_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_load_data_into_cbed_related_signal_err_msg_1 = \
    ("The HDF5 dataset at the HDF5 path ``'{}'`` of the HDF5 file at the file "
     "path ``'{}'``, from which to load the desired ``hyperspy`` signal data, "
     "does not have the expected/correct shape.")

_sizes_of_navigational_space_axes_for_cbed_intensity_patterns_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_sizes_of_navigational_space_axes_for_com_momenta_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_sizes_of_navigational_space_axes_for_stem_images_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_sizes_of_navigational_space_axes_for_intensity_3d_stem_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_sizes_of_navigational_space_axes_for_hrtem_wavefunctions_err_msg_1 = \
    _scan_pattern_type_err_msg_1

_load_data_into_hrtem_related_signal_err_msg_1 = \
    _load_data_into_cbed_related_signal_err_msg_1

_sizes_of_navigational_space_axes_for_hrtem_intensities_err_msg_1 = \
    _scan_pattern_type_err_msg_1
